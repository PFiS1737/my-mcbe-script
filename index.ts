/*!
 * my-mcbe-script-index.js v0.0.0 (https://github.com/PFiS1737/my-mcbe-script#readme)
 * Copyright 2022-2024 PFiS1737
 * Licensed under MIT
 *
 * This file is automatically generated, please do not change it.
 */
import { system, world, Dimension, BlockPermutation, BlockVolume, ItemStack, MinecraftDimensionTypes, Entity, GameMode, EntityDamageCause, DisplaySlotId, ObjectiveSortOrder } from '@minecraft/server';
import { MessageFormData, FormCancelationReason, ModalFormResponse, MessageFormResponse, ActionFormResponse, ModalFormData, ActionFormData } from '@minecraft/server-ui';

class BetterConsole {
    static error(err) {
        console.error(`${err}\n${err.stack}`);
    }
}

function each(target, callbackfn, thisArg) {
    if (Array.isArray(target)) target.forEach(callbackfn, thisArg);
    else if (target?.[Symbol.iterator]) for (const item of target)callbackfn.call(thisArg, item, target);
    else if (typeof target === "object") each(Object.keys(target), (key, i)=>callbackfn.call(thisArg, target[key], key, i, target));
}
async function eachAsync(target, asyncfn, thisArg) {
    if (Array.isArray(target)) for(let i = 0; i < target.length; i++)await asyncfn.call(thisArg, target[i], i, target);
    else if (target?.[Symbol.iterator]) for (const item of target)await asyncfn.call(thisArg, item, target);
    else if (typeof target === "object") await eachAsync(Object.keys(target), async (key, i)=>await asyncfn.call(thisArg, target[key], key, i, target));
}
function safeEval(code, context = {}) {
    const fn = new Function(...Object.keys(context), `return ${code}`);
    return fn(...Object.values(context));
}
function serialize(obj) {
    if (obj instanceof Set) return `new Set(${serialize(Array.from(obj))})`;
    if (obj instanceof Map) return `new Map(${serialize(Array.from(obj.entries()))})`;
    if (Array.isArray(obj)) return `[${obj.map(serialize).join(",")}]`;
    if (typeof obj === "object" && obj !== null) {
        return `{${Object.entries(obj).map(([key, value])=>`${serialize(key)}: ${serialize(value)}`).join(",")}}`;
    }
    return JSON.stringify(obj);
}
function deserialize(str) {
    try {
        return JSON.parse(str);
    } catch (err) {
        // console.warn(`Could not use \`JSON.parse()\` to deserialise the string, trying \`safeEval()\`.`, { string: str })
        return safeEval(`(${str})`);
    }
}
function isAsyncFunc(func) {
    return func[Symbol.toStringTag] === "AsyncFunction";
}

class TypeGroup {
    add(...types) {
        each(types, (type)=>this.types.add(type));
        return this;
    }
    has(type) {
        return this.types.has(type);
    }
    clone() {
        return new TypeGroup([
            ...this
        ]);
    }
    toArray() {
        return Array.from(this);
    }
    [Symbol.iterator]() {
        return this.types.keys();
    }
    constructor(types){
        this.types = new Set(types);
    }
}

const WOODEN_DOORS = new TypeGroup([
    "minecraft:acacia_door",
    "minecraft:bamboo_door",
    "minecraft:birch_door",
    "minecraft:cherry_door",
    "minecraft:crimson_door",
    "minecraft:dark_oak_door",
    "minecraft:jungle_door",
    "minecraft:mangrove_door",
    "minecraft:spruce_door",
    "minecraft:warped_door",
    "minecraft:wooden_door"
]);
const COPPER_DOORS = new TypeGroup([
    "minecraft:copper_door",
    "minecraft:exposed_copper_door",
    "minecraft:weathered_copper_door",
    "minecraft:oxidized_copper_door",
    "minecraft:waxed_copper_door",
    "minecraft:waxed_exposed_copper_door",
    "minecraft:waxed_weathered_copper_door",
    "minecraft:waxed_oxidized_copper_door"
]);
const DOORS = new TypeGroup([
    ...WOODEN_DOORS,
    ...COPPER_DOORS,
    "minecraft:iron_door"
]);
const WOODEN_TRAPDOORS = new TypeGroup([
    "minecraft:acacia_trapdoor",
    "minecraft:bamboo_trapdoor",
    "minecraft:birch_trapdoor",
    "minecraft:cherry_trapdoor",
    "minecraft:crimson_trapdoor",
    "minecraft:dark_oak_trapdoor",
    "minecraft:jungle_trapdoor",
    "minecraft:mangrove_trapdoor",
    "minecraft:spruce_trapdoor",
    "minecraft:trapdoor",
    "minecraft:warped_trapdoor"
]);
const COPPER_TRAPDOORS = new TypeGroup([
    "minecraft:copper_trapdoor",
    "minecraft:exposed_copper_trapdoor",
    "minecraft:weathered_copper_trapdoor",
    "minecraft:oxidized_copper_trapdoor",
    "minecraft:waxed_copper_trapdoor",
    "minecraft:waxed_exposed_copper_trapdoor",
    "minecraft:waxed_weathered_copper_trapdoor",
    "minecraft:waxed_oxidized_copper_trapdoor"
]);
const TRAPDOORS = new TypeGroup([
    ...WOODEN_TRAPDOORS,
    ...COPPER_TRAPDOORS,
    "minecraft:iron_trapdoor"
]);
const LOGS = new TypeGroup([
    "minecraft:acacia_log",
    "minecraft:birch_log",
    "minecraft:cherry_log",
    "minecraft:dark_oak_log",
    "minecraft:jungle_log",
    "minecraft:mangrove_log",
    "minecraft:oak_log",
    "minecraft:spruce_log "
]);
const STEMS = new TypeGroup([
    "minecraft:crimson_stem",
    "minecraft:warped_stem"
]);
const ORES = new TypeGroup([
    "minecraft:coal_ore",
    "minecraft:copper_ore",
    "minecraft:deepslate_coal_ore",
    "minecraft:deepslate_copper_ore",
    "minecraft:deepslate_diamond_ore",
    "minecraft:deepslate_emerald_ore",
    "minecraft:deepslate_gold_ore",
    "minecraft:deepslate_iron_ore",
    "minecraft:deepslate_lapis_ore",
    "minecraft:deepslate_redstone_ore",
    "minecraft:diamond_ore",
    "minecraft:emerald_ore",
    "minecraft:gold_ore",
    "minecraft:iron_ore",
    "minecraft:lapis_ore",
    "minecraft:nether_gold_ore",
    "minecraft:quartz_ore",
    "minecraft:redstone_ore"
]);
const STONES = new TypeGroup([
    "minecraft:stone",
    "minecraft:deepslate"
]);

function round(n) {
    if (n >= 0) return Math.round(n);
    return n % 0.5 === 0 ? Math.floor(n) : Math.round(n);
}
function withProbability(p) {
    return Math.random() <= p;
}
function equals(a, b, epsilon = 0.000001) {
    return Math.abs(a - b) <= epsilon * Math.max(1, Math.abs(a), Math.abs(b));
}
function factorial(n) {
    return n > 1 ? n * factorial(n - 1) : 1;
}
function combination(n, k) {
    return factorial(n) / (factorial(k) * factorial(n - k));
}
function binomial(a, b, n) {
    return (k)=>a ** (n - k) * b ** k * combination(n, k);
}
function binomialDistribution(n, p) {
    return binomial(1 - p, p, n);
}
function range(from, to, step = 1) {
    const output = [];
    for(let i = from; i < to; i += step)output.push(i);
    return output;
}

/**
 * Class representing an N-dimensional vector.
 */ class VectorN {
    /**
   * Create a vector.
   * @param {Array<number>|string} vector - The vector wrote in array or string.
   * @returns {VectorN} The vector.
   */ static create(vector) {
        if (Array.isArray(vector)) return new this(...vector);
        if (typeof vector === "string") return this.parse(vector);
    }
    /**
   * Parse a string to vector.
   * @param {string} vectorStr - The string to parse.
   * @returns {VectorN} The vector.
   */ static parse(vectorStr) {
        return this.create(vectorStr.split(" ").map(Number));
    }
    /**
   * Convert the vector to a string.
   * @returns {string} The string representation of the vector.
   */ stringify() {
        // @ts-ignore
        return this[Symbol.toPrimitive]("string");
    }
    /**
   * Convert the vector to an array.
   * @returns {Array<number>} The array representation of the vector.
   */ toArray() {
        return [
            ...this
        ];
    }
    /**
   * Convert the vector to a primitive value.
   * @param {string} hint - The type hint.
   * @returns {string|VectorN} The string representation or the vector itself.
   */ [Symbol.toPrimitive](hint) {
        if (hint === "string") return this.axes.join(" ");
        return this;
    }
    /**
   * Iterator for the vector axes.
   * @returns {Iterator<number>} The iterator for the axes.
   */ [Symbol.iterator]() {
        return this.axes[Symbol.iterator]();
    }
    /**
   * Get the number of dimensions of the vector.
   * @returns {number} The number of dimensions.
   */ get dimensions() {
        return this.axes.length;
    }
    /**
   * Get an axis of the vector by index.
   * @param {number} index - The index of the component.
   * @returns {number} The component value.
   */ get(index) {
        return this.axes[index];
    }
    /**
   * Set an axis of the vector by index.
   * @param {number} index - The index of the component.
   * @param {number} value - The value to set.
   */ set(index, value) {
        this.axes[index] = value;
    }
    /**
   * Apply a function to each axes of the vector and return a new vector.
   * @param {function(number, number): number} callbackfn - The function to apply.
   * @returns {VectorN} The new vector.
   */ map(callbackfn) {
        return VectorN.create(this.axes.map(callbackfn));
    }
    /**
   * Create a vector.
   * @param {...number} axes - The axes of the vector.
   */ constructor(...axes){
        this.axes = axes;
    }
}

/**
 * Utility class for operations on N-dimensional vectors.
 */ class VectorNUtils {
    /**
   * Create a vector.
   * @param {Array<number>} vector - The vector write in array.
   * @returns {VectorN} The vector.
   */ static create(vector) {
        return VectorN.create(vector);
    }
    /**
   * Clone a vector.
   * @param {VectorN} a - The vector to clone.
   * @returns {VectorN} The cloned vector.
   */ static clone(a) {
        return this.create(a.toArray());
    }
    /**
   * Assert that two vectors have the same dimensions.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @throws Will throw an error if the vectors do not have the same dimensions.
   */ static _assertDimensions(a, b) {
        if (a.dimensions !== b.dimensions) throw new Error("Vectors must have the same dimensions.");
    }
    /**
   * Add two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {VectorN} The resulting vector.
   */ static add(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val + b.get(index));
    }
    /**
   * Subtract one vector from another.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {VectorN} The resulting vector.
   */ static subtract(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val - b.get(index));
    }
    /**
   * Multiply two vectors component-wise.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {VectorN} The resulting vector.
   */ static multiply(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val * b.get(index));
    }
    /**
   * Divide one vector by another component-wise.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {VectorN} The resulting vector.
   */ static divide(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val / b.get(index));
    }
    /**
   * Scale a vector by a scalar.
   * @param {VectorN} a - The vector to scale.
   * @param {number} n - The scalar value.
   * @returns {VectorN} The resulting vector.
   */ static scale(a, n) {
        return a.map((val)=>val * n);
    }
    /**
   * Negate a vector.
   * @param {VectorN} a - The vector to negate.
   * @returns {VectorN} The resulting vector.
   */ static negate(a) {
        return a.map((val)=>-val);
    }
    /**
   * Invert a vector component-wise.
   * @param {VectorN} a - The vector to invert.
   * @returns {VectorN} The resulting vector.
   */ static inverse(a) {
        return a.map((val)=>1 / val);
    }
    /**
   * Exchange two axes of a vector.
   * @param {VectorN} a - The vector to modify.
   * @param {number} axis1 - The first axis to exchange.
   * @param {number} axis2 - The second axis to exchange
   * @returns {VectorN} The resulting vector.
   * @throws Will throw an error if the length of the axes array is not 2.
   */ static exchange(a, axis1, axis2) {
        const output = this.clone(a);
        const n0 = output.get(axis1);
        const n1 = output.get(axis2);
        output.set(axis1, n1);
        output.set(axis2, n0);
        return output;
    }
    /**
   * Check if two vectors are exactly equal.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {boolean} True if the vectors are exactly equal, otherwise false.
   */ static exactEquals(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.axes.every((val, index)=>val === b.get(index));
    }
    /**
   * Check if two vectors are approximately equal.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {boolean} True if the vectors are approximately equal, otherwise false.
   */ static equals(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.axes.every((val, index)=>equals(val, b.get(index)));
    }
    /**
   * Get the component-wise maximum of multiple vectors.
   * @param {...VectorN} vectors - The vectors to compare.
   * @returns {VectorN} The resulting vector.
   */ static max(...vectors) {
        const length = vectors[0].dimensions;
        const maxAxes = vectors.reduce((acc, vector)=>{
            vector.axes.forEach((val, index)=>{
                if (val > acc[index]) acc[index] = val;
            });
            return acc;
        }, new Array(length).fill(Number.NEGATIVE_INFINITY));
        return this.create(maxAxes);
    }
    /**
   * Get the component-wise minimum of multiple vectors.
   * @param {...VectorN} vectors - The vectors to compare.
   * @returns {VectorN} The resulting vector.
   */ static min(...vectors) {
        const length = vectors[0].dimensions;
        const minAxes = vectors.reduce((acc, vector)=>{
            vector.axes.forEach((val, index)=>{
                if (val < acc[index]) acc[index] = val;
            });
            return acc;
        }, new Array(length).fill(Number.POSITIVE_INFINITY));
        return this.create(minAxes);
    }
    /**
   * Apply the floor function to each component of a vector.
   * @param {VectorN} a - The vector to modify.
   * @returns {VectorN} The resulting vector.
   */ static floor(a) {
        return a.map((val)=>Math.floor(val));
    }
    /**
   * Apply the ceil function to each component of a vector.
   * @param {VectorN} a - The vector to modify.
   * @returns {VectorN} The resulting vector.
   */ static ceil(a) {
        return a.map((val)=>Math.ceil(val));
    }
    /**
   * Apply the round function to each component of a vector.
   * @param {VectorN} a - The vector to modify.
   * @returns {VectorN} The resulting vector.
   */ static round(a) {
        return a.map((val)=>round(val));
    }
    /**
   * Apply the absolute value function to each component of a vector.
   * @param {VectorN} a - The vector to modify.
   * @returns {VectorN} The resulting vector.
   */ static abs(a) {
        return a.map((val)=>Math.abs(val));
    }
    /**
   * Get the vector with the maximum magnitude from a list of vectors.
   * @param {...VectorN} vectors - The vectors to compare.
   * @returns {VectorN} The vector with the maximum magnitude.
   */ static maxMagnitude(...vectors) {
        return vectors.reduce((prev, curr)=>VectorNUtils.magnitude(curr) > VectorNUtils.magnitude(prev) ? curr : prev);
    }
    /**
   * Get the vector with the minimum magnitude from a list of vectors.
   * @param {...VectorN} vectors - The vectors to compare.
   * @returns {VectorN} The vector with the minimum magnitude.
   */ static minMagnitude(...vectors) {
        return vectors.reduce((prev, curr)=>VectorNUtils.magnitude(curr) < VectorNUtils.magnitude(prev) ? curr : prev);
    }
    /**
   * Calculate the magnitude of a vector.
   * @param {VectorN} a - The vector to calculate the magnitude of.
   * @returns {number} The magnitude of the vector.
   */ static magnitude(a) {
        return Math.sqrt(VectorNUtils.squaredMagnitude(a));
    }
    /**
   * Calculate the squared magnitude of a vector.
   * @param {VectorN} a - The vector to calculate the squared magnitude of.
   * @returns {number} The squared magnitude of the vector.
   */ static squaredMagnitude(a) {
        return a.axes.reduce((sum, val)=>sum + val ** 2, 0);
    }
    /**
   * Calculate the distance between two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {number} The distance between the vectors.
   */ static distance(a, b) {
        return Math.sqrt(VectorNUtils.squaredDistance(a, b));
    }
    /**
   * Calculate the squared distance between two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {number} The squared distance between the vectors.
   */ static squaredDistance(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.axes.reduce((sum, val, index)=>{
            const diff = val - b.get(index);
            return sum + diff ** 2;
        }, 0);
    }
    /**
   * Calculate the dot product of two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {number} The dot product of the vectors.
   */ static dot(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.axes.reduce((sum, val, index)=>sum + val * b.get(index), 0);
    }
    /**
   * Normalize a vector.
   * @param {VectorN} a - The vector to normalize.
   * @returns {VectorN} The normalized vector.
   */ static normalize(a) {
        const magnitude = this.magnitude(a);
        if (magnitude) return this.scale(a, 1 / magnitude);
        return this.create(new Array(a.dimensions).fill(0));
    }
    /**
   * Calculate the angle between two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {number} The angle between the vectors in radians.
   */ static angle(a, b) {
        const cosOmega = this.dot(this.normalize(a), this.normalize(b));
        return Math.acos(cosOmega);
    }
    /**
   * Generate a random vector.
   * @param {number} dimensions - The number of dimensions.
   * @param {number} [scale=1] - The scale of the random components.
   * @returns {VectorN} The random vector.
   */ static random(dimensions, scale = 1) {
        const axes = Array.from({
            length: dimensions
        }, ()=>Math.random() * 2 - 1);
        return this.scale(this.create(axes), scale);
    }
    /**
   * Perform linear interpolation between two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @param {number} t - The interpolation parameter.
   * @returns {VectorN} The interpolated vector.
   */ static lerp(a, b, t) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val * (1 - t) + b.get(index) * t);
    }
    /**
   * Perform spherical linear interpolation between two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @param {number} t - The interpolation parameter.
   * @returns {VectorN} The interpolated vector.
   */ static slerp(a, b, t) {
        if (t <= 0) return this.clone(a);
        if (t >= 1) return this.clone(b);
        const omega = this.angle(a, b);
        const sinOmega = Math.sin(omega);
        if (sinOmega <= Number.EPSILON) return this.lerp(a, b, t);
        const ratioA = Math.sin(omega * (1 - t)) / sinOmega;
        const ratioB = Math.sin(omega * t) / sinOmega;
        return a.map((val, index)=>val * ratioA + b.get(index) * ratioB);
    }
    /**
   * Perform Bezier interpolation between vectors.
   * @param {VectorN[]} points - The control points.
   * @param {number} t - The interpolation parameter.
   * @returns {VectorN} The interpolated vector.
   */ static bezier(points, t) {
        const n = points.length - 1;
        if (!n) return points[0];
        const newPoints = [];
        for(let i = 0; i < n; i++){
            newPoints.push(this.lerp(points[i], points[i + 1], t));
        }
        return this.bezier(newPoints, t);
    }
}

/**
 * Utility class for operations on 3D vectors.
 */ class Vector3Utils extends VectorNUtils {
    /**
   * @param {Array<number>|string|{x:number,y:number,z:number}} vector - The vector write in array.
   * @returns {Vector3} The vector.
   */ static create(vector) {
        return Vector3.create(vector);
    }
    /**
   * Calculate the cross product of two 3D vectors.
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @returns {Vector3} The cross product of the vectors.
   */ static cross(a, b) {
        return this.create([
            a.y * b.z - a.z * b.y,
            a.z * b.x - a.x * b.z,
            a.x * b.y - a.y * b.x
        ]);
    }
}

/**
 * Class representing a 3-dimensional vector.
 * @extends VectorN
 */ class Vector3 extends VectorN {
    get x() {
        return this.get(0);
    }
    set x(value) {
        this.set(0, value);
    }
    get y() {
        return this.get(1);
    }
    set y(value) {
        this.set(1, value);
    }
    get z() {
        return this.get(2);
    }
    set z(value) {
        this.set(2, value);
    }
    /**
   * @param {Array<number>|string|{x:number,y:number,z:number}} vector - The vector write in array.
   * @returns {Vector3} The vector.
   */ static create(vector) {
        if (Array.isArray(vector)) return new this(...vector);
        // @ts-ignore
        if (typeof vector === "string") return this.parse(vector);
        if (typeof vector === "object") return new this(vector.x, vector.y, vector.z);
    }
    get magnitude() {
        return Vector3Utils.magnitude(this);
    }
    get squaredMagnitude() {
        return Vector3Utils.squaredMagnitude(this);
    }
    get normalized() {
        return Vector3Utils.normalize(this);
    }
    get floored() {
        return Vector3Utils.floor(this);
    }
    get ceiled() {
        return Vector3Utils.ceil(this);
    }
    get rounded() {
        return Vector3Utils.round(this);
    }
    get absoluted() {
        return Vector3Utils.abs(this);
    }
    /**
   * Apply a function to each axes of the vector and return a new vector.
   * @param {function(number, number): number} callbackfn - The function to apply.
   * @returns {Vector3} The new vector.
   */ map(callbackfn) {
        return Vector3.create(this.axes.map(callbackfn));
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    clone() {
        return new Vector3(this.x, this.y, this.z);
    }
    equals(v) {
        return Vector3Utils.equals(this, v);
    }
    distanceTo(v) {
        return Vector3Utils.distance(this, v);
    }
    squaredDistanceTo(v) {
        return Vector3Utils.squaredDistance(this, v);
    }
    add(v) {
        return this.copy(Vector3Utils.add(this, v));
    }
    subtract(v) {
        return this.copy(Vector3Utils.subtract(this, v));
    }
    multiply(v) {
        return this.copy(Vector3Utils.multiply(this, v));
    }
    divide(v) {
        return this.copy(Vector3Utils.divide(this, v));
    }
    scale(n) {
        return this.copy(Vector3Utils.scale(this, n));
    }
    negate() {
        return this.copy(Vector3Utils.negate(this));
    }
    inverse() {
        return this.copy(Vector3Utils.inverse(this));
    }
    floor() {
        return this.copy(this.floored);
    }
    ceil() {
        return this.copy(this.ceiled);
    }
    round() {
        return this.copy(this.rounded);
    }
    abs() {
        return this.copy(this.absoluted);
    }
    normalize() {
        return this.copy(this.normalized);
    }
    /**
   * Create a 3D vector.
   * @param {number} x - The x axis.
   * @param {number} y - The y axis.
   * @param {number} z - The z axis.
   */ constructor(x = 0, y = 0, z = 0){
        super(x, y, z);
    }
}

class Location extends Vector3 {
    get centerCorrected() {
        return Location.create(// @ts-ignore
        Vector3Utils.add(this.floored, new Vector3(0.5, 0.5, 0.5)));
    }
    clone() {
        return new Location(this.x, this.y, this.z);
    }
    equals(v) {
        return Vector3Utils.exactEquals(this, v);
    }
    isNearTo(v, distance) {
        return this.distanceTo(v) <= distance;
    }
    offset(v) {
        return this.add(v);
    }
}

class LocationUtils {
    static getDirectionOffset(direction) {
        return Location.create({
            x: direction.isEast() ? +1 : direction.isWest() ? -1 : 0,
            y: direction.isUp() ? +1 : direction.isDown() ? -1 : 0,
            z: direction.isSouth() ? +1 : direction.isNorth() ? -1 : 0
        });
    }
    static between(a, b, s = 1) {
        const output = [];
        for(let x = a.x; x <= b.x; x += s){
            for(let y = a.y; y <= b.y; y += s){
                for(let z = a.z; z <= b.z; z += s){
                    output.push(new Location(x, y, z));
                }
            }
        }
        return output;
    }
}

class BlockLocation extends Location {
    // @ts-ignore
    get centerCorrected() {
        throw new Error('Couldn\'t get "centerCorrected" on BlockLocation.');
    }
    // @ts-ignore
    clone() {
        return new BlockLocation(this.x, this.y, this.z);
    }
    divide(v) {
        super.divide(v);
        return this.floor();
    }
    // @ts-ignore
    inverse() {
        throw new Error('Couldn\'t call "inverse" on BlockLocation.');
    }
    between(v) {
        return LocationUtils.between(this, v);
    }
    constructor(x, y, z){
        super(x, y, z);
        this.floor();
    }
}

function asyncRun(fn) {
    return new Promise((resolve, reject)=>{
        system.run(()=>{
            try {
                resolve(fn());
            } catch (err) {
                reject(err);
            }
        });
    });
}
function errorHandler(errText, target) {
    const err = new Error(errText);
    target.sendMessage(err.toString());
    return err;
}
function waitForFirstPlayerInitialSpawn() {
    const players = world.getAllPlayers();
    if (players.length) return Promise.resolve(players[0]);
    return new Promise((resolve)=>{
        const callback = world.afterEvents.playerSpawn.subscribe((event)=>{
            if (event.initialSpawn) resolve(event.player);
            world.afterEvents.playerSpawn.unsubscribe(callback);
        });
    });
}
function getOrAddObjective(id, name) {
    const objective = world.scoreboard.getObjective(id);
    if (!objective && !name) throw new Error(`Couldn't find objective "${id}".`);
    if (!objective) return world.scoreboard.addObjective(id, name);
    return objective;
}
function removeMinecraftNamespace(identifier) {
    return identifier.replace(/^minecraft\:/, "");
}

class LocationInfo {
    textify() {
        return {
            location: `${this.location}`,
            dimension: this.dimension.id
        };
    }
    [Symbol.toPrimitive](hint) {
        if (hint === "string") return `${removeMinecraftNamespace(this.dimension.id)}: ${this.location}`;
        return this;
    }
    constructor({ location, dimension }){
        this.location = location instanceof Location ? location : Location.create(location);
        this.dimension = dimension instanceof Dimension ? dimension : world.getDimension(dimension);
    }
}

class Direction {
    get name() {
        switch(this.code){
            case 0:
                return "East";
            case 1:
                return "South";
            case 2:
                return "Up";
            case 3:
                return "West";
            case 4:
                return "North";
            case 5:
                return "Down";
        }
    }
    isEast() {
        return this.code === 0;
    }
    isSouth() {
        return this.code === 1;
    }
    isUp() {
        return this.code === 2;
    }
    isWest() {
        return this.code === 3;
    }
    isNorth() {
        return this.code === 4;
    }
    isDown() {
        return this.code === 5;
    }
    equals(direction) {
        return this.code === direction.code;
    }
    getOpposite() {
        const directionCode = this.code + 3;
        return new Direction(directionCode >= 6 ? directionCode - 6 : directionCode);
    }
    isOppositeTo(direction) {
        return Math.abs(this.code - direction.code) === 3;
    }
    constructor(directionCode){
        this.code = directionCode;
    }
}
class Directions {
}
Directions.East = new Direction(0) // x+
;
Directions.South = new Direction(1) // z+
;
Directions.Up = new Direction(2) // y+
;
Directions.West = new Direction(3) // x-
;
Directions.North = new Direction(4) // z-
;
Directions.Down = new Direction(5) // y-
;

class WrapperTemplate {
    static wrap(...args) {
        // return the class extending this
        // @ts-ignore
        return new this(...args);
    }
    static tryWrap(...args) {
        try {
            // return the class extending this
            // @ts-ignore
            return new this(...args);
        } catch (err) {}
    }
    static match() {
        throw new Error("Not implemented.");
    }
    static assert() {
        throw new Error("Not implemented.");
    }
}

const DIAMOND_PICKAXE_OR_UPPER = new TypeGroup([
    "minecraft:diamond_pickaxe",
    "minecraft:netherite_pickaxe"
]);
const IRON_PICKAXE_OR_UPPER = new TypeGroup([
    ...DIAMOND_PICKAXE_OR_UPPER,
    "minecraft:iron_pickaxe"
]);
const STONE_PICKAXE_OR_UPPER = new TypeGroup([
    ...IRON_PICKAXE_OR_UPPER,
    "minecraft:stone_pickaxe"
]);
const WOODEN_PICKAXE_OR_UPPER = new TypeGroup([
    ...STONE_PICKAXE_OR_UPPER,
    "minecraft:golden_pickaxe",
    "minecraft:wooden_pickaxe"
]);

class WrappedItemStack extends WrapperTemplate {
    hasComponent(componentId) {
        return this._item.hasComponent(componentId);
    }
    get enchants() {
        return this.components.get("enchantable");
    }
    constructor(itemStack){
        super();
        this.components = new Map();
        this._item = itemStack;
        this.type = itemStack.type;
        this.typeId = itemStack.typeId;
        const components = itemStack.getComponents();
        each(components, (component)=>{
            this.components.set(removeMinecraftNamespace(component.typeId), component);
        });
    }
}

class ItemStackWithDurability extends WrappedItemStack {
    static match(itemStack) {
        return itemStack.hasComponent("minecraft:durability");
    }
    get damage() {
        return this.components.get("durability").damage;
    }
    set damage(value) {
        this.components.get("durability").damage = value < 0 ? 0 : value;
    }
    get maxDurability() {
        return this.components.get("durability").maxDurability;
    }
    get durability() {
        return this.maxDurability - this.damage;
    }
    set durability(value) {
        this.damage += this.durability - value;
    }
    applyDamage(damage) {
        const unbreakingLevel = this.enchants.hasEnchantment("unbreaking");
        const probability = this.components.get("durability").getDamageChance(unbreakingLevel) / 100;
        for(let i = 0; i < damage; i++){
            if (withProbability(probability)) this.durability -= 1;
        }
        return this;
    }
    constructor(itemStack){
        if (!ItemStackWithDurability.match(itemStack)) throw new TypeError(`The "${itemStack.typeId}" doesn't have the "minecraft:durability" component.`);
        super(itemStack);
    }
}

var acaciaLog = {
    drops: [
        {
            dig_by: "<default>",
            raw: {
                item_id: "minecraft:acacia_log"
            }
        }
    ]
};

var amethystBlock = {
    drops: [
        {
            dig_by: WOODEN_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:amethyst_block"
            }
        }
    ]
};

var amethystCluster = {
    drops: [
        {
            dig_by: WOODEN_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:amethyst_shard",
                default_range: [
                    4,
                    4
                ]
            },
            fortune_rule: "ore"
        },
        {
            dig_by: "<default>",
            raw: {
                item_id: "minecraft:amethyst_shard",
                default_range: [
                    2,
                    2
                ]
            }
        }
    ]
};

var ancientDebris = {
    drops: [
        {
            dig_by: DIAMOND_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:ancient_debris"
            },
            refined: {
                item_id: "minecraft:netherite_scrap"
            }
        }
    ]
};

var birchLog = {
    drops: [
        {
            dig_by: "<default>",
            raw: {
                item_id: "minecraft:birch_log"
            }
        }
    ]
};

var cherryLog = {
    drops: [
        {
            dig_by: "<default>",
            raw: {
                item_id: "minecraft:cherry_log"
            }
        }
    ]
};

var coalOre = {
    drops: [
        {
            dig_by: WOODEN_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:coal",
                xp_range: [
                    0,
                    2
                ]
            },
            fortune_rule: "ore"
        }
    ]
};

var copperOre = {
    drops: [
        {
            dig_by: STONE_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:raw_copper",
                default_range: [
                    2,
                    5
                ]
            },
            refined: {
                item_id: "minecraft:copper_ingot"
            },
            fortune_rule: "ore"
        }
    ]
};

var crimsonStem = {
    drops: [
        {
            dig_by: "<default>",
            raw: {
                item_id: "minecraft:crimson_stem"
            }
        }
    ]
};

var darkOakLog = {
    drops: [
        {
            dig_by: "<default>",
            raw: {
                item_id: "minecraft:dark_oak_log"
            }
        }
    ]
};

var deepslate = {
    drops: [
        {
            dig_by: WOODEN_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:cobbled_deepslate"
            }
        }
    ]
};

var deepslateCoalOre = {
    drops: [
        {
            dig_by: WOODEN_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:coal",
                xp_range: [
                    0,
                    2
                ]
            },
            fortune_rule: "ore"
        }
    ]
};

var deepslateCopperOre = {
    drops: [
        {
            dig_by: STONE_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:raw_copper",
                default_range: [
                    2,
                    5
                ]
            },
            refined: {
                item_id: "minecraft:copper_ingot"
            },
            fortune_rule: "ore"
        }
    ]
};

var deepslateDiamondOre = {
    drops: [
        {
            dig_by: IRON_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:diamond",
                xp_range: [
                    3,
                    7
                ]
            },
            fortune_rule: "ore"
        }
    ]
};

var deepslateEmeraldOre = {
    drops: [
        {
            dig_by: IRON_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:emerald",
                xp_range: [
                    3,
                    7
                ]
            },
            fortune_rule: "ore"
        }
    ]
};

var deepslateGoldOre = {
    drops: [
        {
            dig_by: IRON_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:raw_gold"
            },
            refined: {
                item_id: "minecraft:gold_ingot"
            },
            fortune_rule: "ore"
        }
    ]
};

var deepslateIronOre = {
    drops: [
        {
            dig_by: STONE_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:raw_iron"
            },
            refined: {
                item_id: "minecraft:iron_ingot"
            },
            fortune_rule: "ore"
        }
    ]
};

var deepslateLapisOre = {
    drops: [
        {
            dig_by: STONE_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:lapis_lazuli",
                default_range: [
                    4,
                    9
                ],
                xp_range: [
                    2,
                    5
                ]
            },
            fortune_rule: "ore"
        }
    ]
};

var deepslateRedstoneOre = {
    drops: [
        {
            dig_by: IRON_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:redstone",
                default_range: [
                    4,
                    5
                ],
                xp_range: [
                    1,
                    5
                ]
            },
            fortune_rule: "melon"
        }
    ]
};

var diamondOre = {
    drops: [
        {
            dig_by: IRON_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:diamond",
                xp_range: [
                    3,
                    7
                ]
            },
            fortune_rule: "ore"
        }
    ]
};

var emeraldOre = {
    drops: [
        {
            dig_by: IRON_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:emerald",
                xp_range: [
                    3,
                    7
                ]
            },
            fortune_rule: "ore"
        }
    ]
};

var goldOre = {
    drops: [
        {
            dig_by: IRON_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:raw_gold"
            },
            refined: {
                item_id: "minecraft:gold_ingot"
            },
            fortune_rule: "ore"
        }
    ]
};

var ironOre = {
    drops: [
        {
            dig_by: STONE_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:raw_iron"
            },
            refined: {
                item_id: "minecraft:iron_ingot"
            },
            fortune_rule: "ore"
        }
    ]
};

var jungleLog = {
    drops: [
        {
            dig_by: "<default>",
            raw: {
                item_id: "minecraft:jungle_log"
            }
        }
    ]
};

var lapisOre = {
    drops: [
        {
            dig_by: STONE_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:lapis_lazuli",
                default_range: [
                    4,
                    9
                ],
                xp_range: [
                    2,
                    5
                ]
            },
            fortune_rule: "ore"
        }
    ]
};

var mangroveLog = {
    drops: [
        {
            dig_by: "<default>",
            raw: {
                item_id: "minecraft:mangrove_log"
            }
        }
    ]
};

var netherGoldOre = {
    drops: [
        {
            dig_by: WOODEN_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:gold_nugget",
                default_range: [
                    2,
                    6
                ],
                xp_range: [
                    0,
                    1
                ]
            },
            refined: {
                item_id: "minecraft:gold_ingot"
            },
            fortune_rule: "ore"
        }
    ]
};

var oakLog = {
    drops: [
        {
            dig_by: "<default>",
            raw: {
                item_id: "minecraft:oak_log"
            }
        }
    ]
};

var obsidian = {
    drops: [
        {
            dig_by: DIAMOND_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:obsidian"
            }
        }
    ]
};

var quartzOre = {
    drops: [
        {
            dig_by: WOODEN_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:quartz",
                xp_range: [
                    2,
                    5
                ]
            },
            fortune_rule: "ore"
        }
    ]
};

var redstoneOre = {
    drops: [
        {
            dig_by: IRON_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:redstone",
                default_range: [
                    4,
                    5
                ],
                xp_range: [
                    1,
                    5
                ]
            },
            fortune_rule: "melon"
        }
    ]
};

var spruceLog = {
    drops: [
        {
            dig_by: "<default>",
            raw: {
                item_id: "minecraft:spruce_log"
            }
        }
    ]
};

var stone = {
    drops: [
        {
            dig_by: WOODEN_PICKAXE_OR_UPPER.toArray(),
            raw: {
                item_id: "minecraft:cobblestone"
            },
            refined: {
                item_id: "minecraft:smooth_stone"
            }
        }
    ]
};

var warpedStem = {
    drops: [
        {
            dig_by: "<default>",
            raw: {
                item_id: "minecraft:warped_stem"
            }
        }
    ]
};

// This file is automatically generated.
var BlockDefinition = {
    "acacia_log": acaciaLog,
    "amethyst_block": amethystBlock,
    "amethyst_cluster": amethystCluster,
    "ancient_debris": ancientDebris,
    "birch_log": birchLog,
    "cherry_log": cherryLog,
    "coal_ore": coalOre,
    "copper_ore": copperOre,
    "crimson_stem": crimsonStem,
    "dark_oak_log": darkOakLog,
    "deepslate": deepslate,
    "deepslate_coal_ore": deepslateCoalOre,
    "deepslate_copper_ore": deepslateCopperOre,
    "deepslate_diamond_ore": deepslateDiamondOre,
    "deepslate_emerald_ore": deepslateEmeraldOre,
    "deepslate_gold_ore": deepslateGoldOre,
    "deepslate_iron_ore": deepslateIronOre,
    "deepslate_lapis_ore": deepslateLapisOre,
    "deepslate_redstone_ore": deepslateRedstoneOre,
    "diamond_ore": diamondOre,
    "emerald_ore": emeraldOre,
    "gold_ore": goldOre,
    "iron_ore": ironOre,
    "jungle_log": jungleLog,
    "lapis_ore": lapisOre,
    "mangrove_log": mangroveLog,
    "nether_gold_ore": netherGoldOre,
    "oak_log": oakLog,
    "obsidian": obsidian,
    "quartz_ore": quartzOre,
    "redstone_ore": redstoneOre,
    "spruce_log": spruceLog,
    "stone": stone,
    "warped_stem": warpedStem
};

class NumberRange {
    toArray() {
        return range(this.min, this.max + this.step, this.step);
    }
    get array() {
        return this.toArray();
    }
    includes(n) {
        return this.array.includes(n);
    }
    [Symbol.iterator]() {
        return this.array.values();
    }
    constructor(min, max, step = 1){
        this.min = min;
        this.max = max;
        this.step = step;
    }
}

class LootTable {
    addItem(item) {
        this.table.add(item);
        this.totalWeight += item.weight;
    }
    getResult() {
        let total = 0;
        for (const { weight, value } of this.table){
            if (withProbability(weight / (this.totalWeight - total))) return value;
            total += weight;
        }
    }
    [Symbol.iterator]() {
        return this.table[Symbol.iterator]();
    }
    constructor(items){
        this.table = new Set();
        this.totalWeight = 0;
        if (items) each(items, (item)=>{
            if (typeof item === "number") this.addItem({
                weight: 1,
                value: item
            });
            else this.addItem(item);
        });
    }
}

class DropItem {
    getResult() {
        return [
            {
                itemId: this.itemId,
                amount: Math.min(this.amountLootTable.getResult(), this.maxAmount),
                xp: new LootTable(this.xpRange.toArray()).getResult(),
                damage: this.damage
            }
        ];
    }
    constructor({ // @ts-ignore
    item_id: itemId, default_range: defaultRange = [
        1,
        1
    ], max_amount: maxAmount = Number.POSITIVE_INFINITY, xp_range: xpRange = [
        0,
        0
    ], damage = 1 } = {}){
        this.itemId = itemId;
        this.range = new NumberRange(...defaultRange);
        this.amountLootTable = new LootTable(this.range.toArray());
        this.maxAmount = maxAmount;
        this.xpRange = new NumberRange(...xpRange);
        this.damage = damage;
    }
}
class DropItemGroup {
    getResult() {
        const output = [];
        each(this.items, (item)=>output.push(...item.getResult()));
        return output;
    }
    constructor(group){
        this.items = group.map((e)=>new DropItem(e));
    }
}
const FORTUNE_RULES = {
    // 掉落一个权重为 2，每级增加一个掉落上限，权重为 1
    ore: "ore",
    // 掉落一个权重为 1，每级增加一个掉落上限，权重为 1，但不超过某上限
    melon: "melon",
    // 是否掉落有一固定概率
    // 如果判定掉落，每级增加两个掉落上限，权重为 1
    grass: "grass",
    // 掉落一个权重为 1，每级增加两个掉落上限，权重为 1
    flower: "flower",
    // 固定掉落一个
    // 额外掉落上限初始为 3，每级增加一个额外掉落上限，额外掉落服从 B(n, 4 / 7)
    crop: "crop",
    // 使用自定义的战利品表
    custom: "custom"
};
class BlockDrops {
    setItemUse(useItem = "<empty>") {
        const dropConfig = this.drops.find((e)=>{
            const digBy = e.dig_by;
            if (Array.isArray(digBy)) return digBy.includes(useItem);
            if (typeof digBy === "string") return digBy === useItem;
        }) ?? this.drops.find((e)=>e.dig_by === "<default>");
        if (!dropConfig) {
            // throw new Error(`Couldn't find drop config when dig with ${useItem}`)
            return false;
        }
        this.blockItem = new DropItem({
            item_id: BlockPermutation.resolve(this.blockTypeId).getItemStack()?.typeId
        });
        this.rawResource = new DropItem(dropConfig.raw) ?? this.blockItem;
        // for ore like
        this.refinedResource = new DropItem(dropConfig.refined);
        // for crop like
        this.seendResource = new DropItem(dropConfig.seed) ?? this.rawResource;
        this.immatureResource = new DropItem(dropConfig.immature) ?? this.seendResource;
        this.fortuneRule = dropConfig.fortune_rule;
        // only work with custom rule
        if (this.fortuneRule === FORTUNE_RULES.custom) {
            this.custumLootTable = dropConfig.option?.custom;
            if (!this.custumLootTable) throw new Error("You must provide a custom loot table for the custom fortune rule.");
        }
        return true;
    }
    getDrops({ withFortune = 0, withSilkTouch = false, immature = false } = {}) {
        if (withFortune && withSilkTouch) throw new Error("Could not call with both fortune and silk_touch.");
        if (immature) {
            return this.immatureResource.getResult();
        }
        if (withSilkTouch) {
            return this.blockItem.getResult();
        }
        if (withFortune !== 0 && this.fortuneRule) {
            const level = withFortune;
            switch(this.fortuneRule){
                case FORTUNE_RULES.ore:
                    {
                        const rawResource = this.rawResource.getResult()[0];
                        const lootTable = new LootTable([
                            ...range(2, level + 2),
                            {
                                weight: 2,
                                value: 1
                            }
                        ]);
                        rawResource.amount *= lootTable.getResult();
                        return [
                            rawResource
                        ];
                    }
                case FORTUNE_RULES.melon:
                    {
                        const rawResource = this.rawResource.getResult()[0];
                        const lootTable = new LootTable([
                            ...this.rawResource.amountLootTable,
                            ...range(1, level + 1).map((i)=>({
                                    weight: 1,
                                    value: Math.min(this.rawResource.maxAmount, this.rawResource.range.max + i)
                                }))
                        ]);
                        rawResource.amount = lootTable.getResult();
                        return [
                            rawResource
                        ];
                    }
                case FORTUNE_RULES.grass:
                    {
                        const rawResource = this.rawResource.getResult()[0];
                        if (rawResource.amount === 0) return [
                            rawResource
                        ];
                        const lootTable = new LootTable(range(1, level * 2 + 2));
                        rawResource.amount = lootTable.getResult();
                        return [
                            rawResource
                        ];
                    }
                case FORTUNE_RULES.flower:
                    {
                        const rawResource = this.rawResource.getResult()[0];
                        const lootTable = new LootTable(range(1, level * 2 + 2));
                        rawResource.amount = lootTable.getResult();
                        return [
                            rawResource
                        ];
                    }
                case FORTUNE_RULES.crop:
                    {
                        const rawResource = this.rawResource.getResult()[0];
                        const distribution = binomialDistribution(level + 3, 4 / 7);
                        const lootTable = new LootTable(range(0, level + 4).map((i)=>({
                                weight: distribution(i),
                                value: i
                            })));
                        return [
                            rawResource,
                            {
                                // TODO: use class
                                itemId: this.seendResource.itemId,
                                amount: lootTable.getResult()
                            }
                        ];
                    }
                case FORTUNE_RULES.custom:
                    {
                        const lootTable = new LootTable(this.custumLootTable[level]);
                        const customItemDrop = new DropItemGroup(lootTable.getResult());
                        return customItemDrop.getResult();
                    }
            }
        // biome-ignore lint/style/noUselessElse: <explanation>
        } else {
            return this.rawResource.getResult();
        }
    }
    constructor(blockTypeId, useItem){
        const identifier = removeMinecraftNamespace(blockTypeId);
        const drops = BlockDefinition[identifier]?.drops;
        if (!drops) throw new Error(`Block ${identifier} has not been supported.`);
        this.blockTypeId = blockTypeId;
        this.drops = drops;
        if (useItem) this.setItemUse(useItem);
    }
}

class WrappedBlock extends WrapperTemplate {
    getOffsetBlock(v) {
        // @ts-ignore
        const location = this.location.clone().offset(v);
        return new WrappedBlock(this.dimension.getBlock(location));
    }
    getNeighbourBlock(direction) {
        const offset = LocationUtils.getDirectionOffset(direction);
        return this.getOffsetBlock(offset);
    }
    getState(name) {
        return this.permutation.getState(name);
    }
    hasState(name) {
        return !!this.getState(name);
    }
    setState(name, value) {
        const states = this.permutation.getAllStates();
        states[name] = value;
        this._block.setPermutation(BlockPermutation.resolve(this.typeId, states));
    }
    canBeDugBy(itemTypeId = "<empty>") {
        return new BlockDrops(this.typeId).setItemUse(itemTypeId);
    }
    destroy() {
        this.dimension.fillBlocks(new BlockVolume(this.location, this.location), BlockPermutation.resolve("minecraft:air"));
    }
    breakBy(useItemStack) {
        const drops = new BlockDrops(this.typeId, useItemStack?.typeId ?? "<empty>");
        this.destroy();
        const result = (()=>{
            if (useItemStack) {
                const item = useItemStack instanceof WrappedItemStack ? useItemStack : new WrappedItemStack(useItemStack);
                return drops.getDrops({
                    withFortune: item.enchants.hasEnchantment("fortune") ? item.enchants.getEnchantment("fortune").level : 0,
                    withSilkTouch: item.enchants.hasEnchantment("silk_touch")
                });
            }
            return drops.getDrops();
        })();
        const spawnDrops = ()=>{
            each(result, (drop)=>{
                this.dimension.spawnItem(new ItemStack(drop.itemId, drop.amount), this.location);
                while(drop.xp--)this.dimension.spawnEntity("minecraft:xp_orb", this.location);
            });
        };
        const getTotalDamage = ()=>{
            let damage = 0;
            each(result, (drop)=>{
                if (drop.damage) damage += drop.damage;
            });
            return damage;
        };
        return {
            drops: result,
            spawnDrops,
            getTotalDamage
        };
    }
    constructor(block){
        super();
        this._block = block;
        this.type = block.type;
        this.typeId = block.typeId;
        this.location = BlockLocation.create(block.location);
        this.dimension = block.dimension;
        this.permutation = block.permutation;
    }
}

class WrappedBlocks extends WrapperTemplate {
    get _block() {
        return this._blocks[0];
    }
    get type() {
        return this._block.type;
    }
    get typeId() {
        return this._block.typeId;
    }
    get location() {
        return this._block.location;
    }
    get dimension() {
        return this._block.dimension;
    }
    get permutation() {
        return this._block.permutation;
    }
    constructor(blocks){
        super();
        this._blocks = (Array.isArray(blocks) ? blocks : [
            blocks
        ]).map((block)=>{
            return block instanceof WrappedBlock // TODO: TypeError
             ? block : new WrappedBlock(block);
        });
    }
}

class BlockList {
    get size() {
        return this.blocks.length;
    }
    add(...blocks) {
        each(blocks, (block)=>{
            if (!this.has(block)) this.blocks.push(block);
        });
    }
    has(block) {
        return this.blocks.some(({ location })=>Vector3Utils.exactEquals(location, block.location));
    }
    shift() {
        return this.blocks.shift();
    }
    [Symbol.iterator]() {
        return this.blocks.values();
    }
    constructor(blocks){
        this.blocks = [];
        if (blocks) this.add(...blocks);
    }
}

class DoorBlock extends WrappedBlocks {
    static match(block) {
        return DOORS.has(block?.typeId);
    }
    static assert(block) {
        if (DoorBlock.match(block)) return true;
        throw new TypeError(`The "${block.typeId}" is not a door.`);
    }
    get _lower() {
        return this._blocks[0];
    }
    get _upper() {
        return this._blocks[1];
    }
    get opened() {
        return this._lower.getState("open_bit");
    }
    get facingDirection() {
        // the direction you are facing when you place the door
        const directionCode = this._lower.getState("direction");
        switch(directionCode){
            case 0:
                return Directions.East;
            case 1:
                return Directions.South;
            case 2:
                return Directions.West;
            case 3:
                return Directions.North;
            default:
                // this branch can't be reached forever
                throw new Error("Unkonw error.");
        }
    }
    get hingeSide() {
        return this._upper.getState("door_hinge_bit");
    // true -> right
    // false -> left
    }
    isWooden() {
        return WOODEN_DOORS.has(this.typeId);
    }
    isCopper() {
        return COPPER_DOORS.has(this.typeId);
    }
    isIron() {
        return !this.canBeOpenedByHand();
    }
    canBeOpenedByHand() {
        return this.isWooden() || this.isCopper();
    }
    open() {
        this._lower.setState("open_bit", true);
    }
    close() {
        this._lower.setState("open_bit", false);
    }
    getRelated({ shouldBeTheSameType = true } = {}) {
        // 获取可以与该门双开的另一个门和这个门组成的列表
        const output = [
            this
        ];
        // 1. 获取另一个门的位置
        //    根据门的方向和门轴位置确定
        // e.g. 如果一个门的朝向是东边，门轴在左边（即北边）
        //      那么另一个门应该位于南边，即 z+1 的位置
        const facingDirection = this.facingDirection;
        const hingeSide = this.hingeSide;
        const offset = BlockLocation.create({
            x: Number(facingDirection.isSouth() ? hingeSide || -1 : facingDirection.isNorth() ? !hingeSide || -1 : 0),
            y: 0,
            z: Number(facingDirection.isEast() ? !hingeSide || -1 : facingDirection.isWest() ? hingeSide || -1 : 0)
        });
        // 2. 进行判断
        const relatedBlock = this._lower.getOffsetBlock(offset);
        if (DoorBlock.match(relatedBlock)) {
            const relatedDoor = new DoorBlock(relatedBlock);
            // 另一扇门应该方向相同，而门轴相反
            if (relatedDoor.canBeOpenedByHand() && (shouldBeTheSameType ? relatedDoor.typeId === this.typeId : true) && relatedDoor.facingDirection.code === facingDirection.code && relatedDoor.hingeSide === !hingeSide) // @ts-ignore
            output.push(relatedDoor);
        }
        return output;
    }
    constructor(block){
        DoorBlock.assert(block);
        const wrappedBlock = block instanceof WrappedBlock ? block : new WrappedBlock(block);
        const isUpper = wrappedBlock.getState("upper_block_bit");
        const blocks = [
            // _lower
            isUpper ? wrappedBlock.getNeighbourBlock(Directions.Down) : wrappedBlock,
            // _upper
            isUpper ? wrappedBlock : wrappedBlock.getNeighbourBlock(Directions.Up)
        ];
        super(blocks);
    }
}

class WrappedEntity extends WrapperTemplate {
    get nameTag() {
        return this._entity.nameTag;
    }
    get location() {
        return Location.create(this._entity.location);
    }
    get dimension() {
        return this._entity.dimension;
    }
    get isSneaking() {
        return this._entity.isSneaking;
    }
    getRotation() {
        return this._entity.getRotation();
    }
    getFacingDirectionXZ() {
        const rotation = this.getRotation().y;
        if (rotation > -135 && rotation <= -45) return Directions.East;
        if (rotation > -45 && rotation <= 45) return Directions.South;
        if (rotation > 45 && rotation <= 135) return Directions.West;
        if (rotation > 135 || rotation <= -135) return Directions.North;
    }
    constructor(entity){
        super();
        this.components = new Map();
        this._entity = entity;
        this.id = entity.id;
        this.typeId = entity.typeId;
        this.scoreboardIdentity = entity.scoreboardIdentity;
        const components = entity.getComponents();
        each(components, (component)=>{
            this.components.set(removeMinecraftNamespace(component.typeId), component);
        });
    }
}

const overworld = world.getDimension(MinecraftDimensionTypes.overworld);
const CUSTOM_COMMAND_SET = new Set();
class Commands {
    static run(commandString, target = overworld) {
        // @ts-ignore
        if (target instanceof Dimension || target instanceof Entity) return target.runCommand(commandString);
        throw new TypeError("Target must be Entity or Dimension.");
    }
    static async asyncRun(commandString, target = overworld) {
        // @ts-ignore
        if (target instanceof Dimension || target instanceof Entity) {
            const customCommands = [
                ...CUSTOM_COMMAND_SET
            ].filter(({ regex })=>regex.test(commandString)).map((e)=>e.runner);
            if (customCommands.length) await eachAsync(customCommands, async (runner)=>await runner(commandString, target));
            else return await target.runCommandAsync(commandString);
        } else throw new TypeError("Target must be Entity or Dimension.");
    }
    static register(prefix, command, /* grammar, */ callback) {
        if (prefix.startsWith("/")) throw new Error("Unable to register slash commands.");
        const regex = new RegExp(`^${prefix}${command}( |$)`);
        const runner = async (commandString, target)=>{
            // callback(new Parser(commandString, grammar), target)
            const argv = commandString.split(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g).filter((e)=>e.trim().length > 0);
            await callback(argv, target);
        };
        CUSTOM_COMMAND_SET.add({
            regex,
            runner
        });
        world.beforeEvents.chatSend.subscribe((event)=>{
            if (regex.test(event.message)) {
                event.cancel = true;
                runner(event.message, event.sender).catch(BetterConsole.error);
            }
        });
    }
}

class Container extends WrapperTemplate {
    get size() {
        return this._container.size;
    }
    get emptySlotsCount() {
        return this._container.emptySlotsCount;
    }
    getItem(slot) {
        return this._container.getItem(slot);
    }
    setItem(slot, itemStack) {
        return this._container.setItem(slot, itemStack);
    }
    tryAddItem(itemStack) {
        return this._container.addItem(itemStack);
    }
    constructor(container){
        super();
        this._container = container;
    }
}

class EntityContainer extends Container {
    get location() {
        return this._entity.location;
    }
    get dimension() {
        return this._entity.dimension;
    }
    addItem(itemStack) {
        const remain = this.tryAddItem(itemStack);
        if (remain) this.dimension.spawnItem(remain, this.location);
    }
    constructor(entity, container){
        super(container);
        this._entity = entity;
    }
}

class WrappedPlayer extends WrappedEntity {
    static match(entity) {
        return entity.typeId === "minecraft:player";
    }
    get _player() {
        return this._entity;
    }
    get experience() {
        return this.addExperience(0);
    }
    get level() {
        return this._player.level;
    }
    get inventory() {
        return new EntityContainer(this, this.components.get("inventory").container);
    }
    get selectedSlotIndex() {
        return this._player.selectedSlotIndex;
    }
    getGameMode() {
        const matches = [];
        each(GameMode, (mode)=>{
            if (this.testGameMode(mode)) matches.push(mode);
        });
        return matches[0];
    }
    testGameMode(mode) {
        const playersUnderMode = this.dimension.getPlayers({
            gameMode: mode
        });
        return playersUnderMode.some((player)=>player.id === this.id);
    }
    setGameMode(mode) {
        if (!Object.values(GameMode).includes(mode)) throw new TypeError("Unknown gamemode.");
        Commands.run(`gamemode ${mode}`, this._player);
    }
    getMainHandItem() {
        return this.inventory.getItem(this.selectedSlotIndex);
    }
    setMainHandItem(item) {
        this.inventory.setItem(this.selectedSlotIndex, item);
    }
    async useItemFromInventory(slot, callback = async (_)=>{}) {
        let itemStack = this.inventory.getItem(slot);
        itemStack = await callback(itemStack);
        this.inventory.setItem(slot, itemStack);
    }
    async useMainHandItem(callback = async ()=>{}) {
        await this.useItemFromInventory(this.selectedSlotIndex, callback);
    }
    addExperience(amount = 0, { useXpOrb = false } = {}) {
        if (useXpOrb && amount >= 0) {
            while(amount--)this.dimension.spawnEntity("minecraft:xp_orb", this.location);
            return this.experience;
        }
        return this._player.addExperience(amount);
    }
    addLevels(amount = 0) {
        return this._player.addLevels(amount);
    }
    constructor(player){
        super(player);
        this.name = player.name;
    }
}

class TrapdoorBlock extends WrappedBlock {
    static match(block) {
        return TRAPDOORS.has(block?.typeId);
    }
    static assert(block) {
        if (TrapdoorBlock.match(block)) return true;
        throw new TypeError(`The "${block.typeId}" is not a trapdoor.`);
    }
    get opened() {
        return this.getState("open_bit");
    }
    get facingDirection() {
        // trapdoor is on the >direction< side of a block
        const directionCode = this.getState("direction");
        switch(directionCode){
            case 0:
                return Directions.East;
            case 2:
                return Directions.South;
            case 1:
                return Directions.West;
            case 3:
                return Directions.North;
            default:
                // this branch can't be reached forever
                throw new Error("Unkonw error.");
        }
    }
    get upsideOrDown() {
        return this.getState("upside_down_bit");
    }
    isWooden() {
        return WOODEN_TRAPDOORS.has(this.typeId);
    }
    isCopper() {
        return COPPER_TRAPDOORS.has(this.typeId);
    }
    isIron() {
        return !this.canBeOpenedByHand();
    }
    canBeOpenedByHand() {
        return this.isWooden() || this.isCopper();
    }
    open() {
        this.setState("open_bit", true);
    }
    close() {
        this.setState("open_bit", false);
    }
    getRelated(player, { extensive = true, maxLength = 1, shouldBeTheSameType = true } = {}) {
        // 获取可以与该活板门双开的另外一些活板门和这个活板门组成的列表
        const output = [
            this
        ];
        if (maxLength > 0) {
            // 1. 获取另一个活板门的位置
            // e.g. 如果一个活板门位于一个方块的东边
            //      那么另一个活板门应该位于东边，即 x+1 的位置
            const relatedBlock = this.getNeighbourBlock(this.facingDirection);
            // 2. 判断是否为相关活板门
            if (TrapdoorBlock.match(relatedBlock)) {
                // TODO: refactor _bloc6k
                const relatedTrapdoor = new TrapdoorBlock(relatedBlock._block);
                // 方向相反，上下位置相同
                if (relatedTrapdoor.canBeOpenedByHand() && (shouldBeTheSameType ? relatedTrapdoor.typeId === this.typeId : true) && relatedTrapdoor.facingDirection.isOppositeTo(this.facingDirection) && relatedTrapdoor.upsideOrDown === this.upsideOrDown) // @ts-ignore
                output.push(relatedTrapdoor);
            }
        }
        if (extensive) {
            let that = this;
            let needOpposite = false;
            // 仅 maxLength > 1 时才会运行
            while(--maxLength){
                // 3. 获取扩展活板门
                //    即能与该活板门延伸联动的另一个活板门
                // @ts-ignore
                const playerFacing = WrappedPlayer.wrap(player).getFacingDirectionXZ();
                const extensiveBlock = needOpposite ? that.getNeighbourBlock(playerFacing.getOpposite()) : that.getNeighbourBlock(playerFacing);
                if (TrapdoorBlock.match(extensiveBlock)) {
                    const extensiveTrapdoor = new TrapdoorBlock(extensiveBlock._block);
                    // 方向相同，上下位置相同
                    if (extensiveTrapdoor.canBeOpenedByHand() && (shouldBeTheSameType ? extensiveTrapdoor.typeId === this.typeId : true) && extensiveTrapdoor.facingDirection.equals(this.facingDirection) && extensiveTrapdoor.upsideOrDown === this.upsideOrDown) {
                        const result = extensiveTrapdoor.getRelated(player, {
                            extensive: false,
                            maxLength
                        });
                        if (result.length > 1) {
                            // @ts-ignore
                            output.push(...result);
                            // @ts-ignore
                            that = extensiveTrapdoor;
                            continue;
                        }
                    }
                }
                // 当玩家面对的方向可以联动的活板门数量不足时
                // 反向查找
                if (!needOpposite) {
                    needOpposite = true;
                    that = this;
                    // 因为此变向操纵消耗了一次迭代，故补充一次
                    maxLength++;
                } else {
                    break;
                }
            }
        }
        return output;
    }
    constructor(block){
        TrapdoorBlock.assert(block);
        super(block);
    }
}

class Dialog {
    static async confirm({ title = "确认", body, target, onCancel = async ()=>{}, onConfirm = async ()=>{} }) {
        if (!body || !target) throw new Error();
        const form = await asyncRun(()=>{
            return new Dialog({
                dialog: new MessageFormData().title(title).body(body).button1("CANCEL").button2("OK"),
                onClose: onCancel,
                onSelectButton1: onCancel,
                onSelectButton2: onConfirm
            });
        });
        return await form.show(target);
    }
    async show(target) {
        let response;
        target.sendMessage("[!] 新对话框已发送，请关闭命令输入栏或其他对话框");
        do {
            response = await this.dialog.show(target);
        }while (response.cancelationReason === FormCancelationReason.UserBusy)
        if (response.canceled && response.cancelationReason === FormCancelationReason.UserClosed) return await this.onClose();
        if (response instanceof ModalFormResponse) return await this.onSubmit(response.formValues);
        if (response instanceof MessageFormResponse) {
            if (response.selection === 0) return await this.onSelectButton1();
            if (response.selection === 1) return await this.onSelectButton2();
        } else if (response instanceof ActionFormResponse) return await this.onSelect(response.selection);
        return response;
    }
    constructor({ dialog, onClose = async ()=>{}, onSubmit = async (_)=>{}, onSelectButton1 = async ()=>{}, onSelectButton2 = async ()=>{}, onSelect = async (_)=>{} }){
        this.dialog = dialog;
        this.onSubmit = onSubmit;
        this.onSelectButton1 = onSelectButton1;
        this.onSelectButton2 = onSelectButton2;
        this.onSelect = onSelect;
        this.onClose = onClose;
    }
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var md5$1 = {exports: {}};

var crypt = {exports: {}};

(function() {
    var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', crypt$1 = {
        // Bit-wise rotation left
        rotl: function(n, b) {
            return n << b | n >>> 32 - b;
        },
        // Bit-wise rotation right
        rotr: function(n, b) {
            return n << 32 - b | n >>> b;
        },
        // Swap big-endian to little-endian and vice versa
        endian: function(n) {
            // If number given, swap endian
            if (n.constructor == Number) {
                return crypt$1.rotl(n, 8) & 0x00FF00FF | crypt$1.rotl(n, 24) & 0xFF00FF00;
            }
            // Else, assume array and swap all items
            for(var i = 0; i < n.length; i++)n[i] = crypt$1.endian(n[i]);
            return n;
        },
        // Generate an array of any length of random bytes
        randomBytes: function(n) {
            for(var bytes = []; n > 0; n--)bytes.push(Math.floor(Math.random() * 256));
            return bytes;
        },
        // Convert a byte array to big-endian 32-bit words
        bytesToWords: function(bytes) {
            for(var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)words[b >>> 5] |= bytes[i] << 24 - b % 32;
            return words;
        },
        // Convert big-endian 32-bit words to a byte array
        wordsToBytes: function(words) {
            for(var bytes = [], b = 0; b < words.length * 32; b += 8)bytes.push(words[b >>> 5] >>> 24 - b % 32 & 0xFF);
            return bytes;
        },
        // Convert a byte array to a hex string
        bytesToHex: function(bytes) {
            for(var hex = [], i = 0; i < bytes.length; i++){
                hex.push((bytes[i] >>> 4).toString(16));
                hex.push((bytes[i] & 0xF).toString(16));
            }
            return hex.join('');
        },
        // Convert a hex string to a byte array
        hexToBytes: function(hex) {
            for(var bytes = [], c = 0; c < hex.length; c += 2)bytes.push(parseInt(hex.substr(c, 2), 16));
            return bytes;
        },
        // Convert a byte array to a base-64 string
        bytesToBase64: function(bytes) {
            for(var base64 = [], i = 0; i < bytes.length; i += 3){
                var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
                for(var j = 0; j < 4; j++)if (i * 8 + j * 6 <= bytes.length * 8) base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 0x3F));
                else base64.push('=');
            }
            return base64.join('');
        },
        // Convert a base-64 string to a byte array
        base64ToBytes: function(base64) {
            // Remove non-base-64 characters
            base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');
            for(var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4){
                if (imod4 == 0) continue;
                bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
            }
            return bytes;
        }
    };
    crypt.exports = crypt$1;
})();

var cryptExports = crypt.exports;

var charenc = {
    // UTF-8 encoding
    utf8: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
            return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
            return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
        }
    },
    // Binary encoding
    bin: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
            for(var bytes = [], i = 0; i < str.length; i++)bytes.push(str.charCodeAt(i) & 0xFF);
            return bytes;
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
            for(var str = [], i = 0; i < bytes.length; i++)str.push(String.fromCharCode(bytes[i]));
            return str.join('');
        }
    }
};
var charenc_1 = charenc;

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
var isBuffer_1 = function(obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}
// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

(function() {
    var crypt = cryptExports, utf8 = charenc_1.utf8, isBuffer = isBuffer_1, bin = charenc_1.bin, // The core
    md5 = function(message, options) {
        // Convert to byte array
        if (message.constructor == String) if (options && options.encoding === 'binary') message = bin.stringToBytes(message);
        else message = utf8.stringToBytes(message);
        else if (isBuffer(message)) message = Array.prototype.slice.call(message, 0);
        else if (!Array.isArray(message) && message.constructor !== Uint8Array) message = message.toString();
        // else, assume byte array already
        var m = crypt.bytesToWords(message), l = message.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
        // Swap endian
        for(var i = 0; i < m.length; i++){
            m[i] = (m[i] << 8 | m[i] >>> 24) & 0x00FF00FF | (m[i] << 24 | m[i] >>> 8) & 0xFF00FF00;
        }
        // Padding
        m[l >>> 5] |= 0x80 << l % 32;
        m[(l + 64 >>> 9 << 4) + 14] = l;
        // Method shortcuts
        var FF = md5._ff, GG = md5._gg, HH = md5._hh, II = md5._ii;
        for(var i = 0; i < m.length; i += 16){
            var aa = a, bb = b, cc = c, dd = d;
            a = FF(a, b, c, d, m[i + 0], 7, -680876936);
            d = FF(d, a, b, c, m[i + 1], 12, -389564586);
            c = FF(c, d, a, b, m[i + 2], 17, 606105819);
            b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
            a = FF(a, b, c, d, m[i + 4], 7, -176418897);
            d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
            c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
            b = FF(b, c, d, a, m[i + 7], 22, -45705983);
            a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
            d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
            c = FF(c, d, a, b, m[i + 10], 17, -42063);
            b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
            a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
            d = FF(d, a, b, c, m[i + 13], 12, -40341101);
            c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
            b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
            a = GG(a, b, c, d, m[i + 1], 5, -165796510);
            d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
            c = GG(c, d, a, b, m[i + 11], 14, 643717713);
            b = GG(b, c, d, a, m[i + 0], 20, -373897302);
            a = GG(a, b, c, d, m[i + 5], 5, -701558691);
            d = GG(d, a, b, c, m[i + 10], 9, 38016083);
            c = GG(c, d, a, b, m[i + 15], 14, -660478335);
            b = GG(b, c, d, a, m[i + 4], 20, -405537848);
            a = GG(a, b, c, d, m[i + 9], 5, 568446438);
            d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
            c = GG(c, d, a, b, m[i + 3], 14, -187363961);
            b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
            a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
            d = GG(d, a, b, c, m[i + 2], 9, -51403784);
            c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
            b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
            a = HH(a, b, c, d, m[i + 5], 4, -378558);
            d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
            c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
            b = HH(b, c, d, a, m[i + 14], 23, -35309556);
            a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
            d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
            c = HH(c, d, a, b, m[i + 7], 16, -155497632);
            b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
            a = HH(a, b, c, d, m[i + 13], 4, 681279174);
            d = HH(d, a, b, c, m[i + 0], 11, -358537222);
            c = HH(c, d, a, b, m[i + 3], 16, -722521979);
            b = HH(b, c, d, a, m[i + 6], 23, 76029189);
            a = HH(a, b, c, d, m[i + 9], 4, -640364487);
            d = HH(d, a, b, c, m[i + 12], 11, -421815835);
            c = HH(c, d, a, b, m[i + 15], 16, 530742520);
            b = HH(b, c, d, a, m[i + 2], 23, -995338651);
            a = II(a, b, c, d, m[i + 0], 6, -198630844);
            d = II(d, a, b, c, m[i + 7], 10, 1126891415);
            c = II(c, d, a, b, m[i + 14], 15, -1416354905);
            b = II(b, c, d, a, m[i + 5], 21, -57434055);
            a = II(a, b, c, d, m[i + 12], 6, 1700485571);
            d = II(d, a, b, c, m[i + 3], 10, -1894986606);
            c = II(c, d, a, b, m[i + 10], 15, -1051523);
            b = II(b, c, d, a, m[i + 1], 21, -2054922799);
            a = II(a, b, c, d, m[i + 8], 6, 1873313359);
            d = II(d, a, b, c, m[i + 15], 10, -30611744);
            c = II(c, d, a, b, m[i + 6], 15, -1560198380);
            b = II(b, c, d, a, m[i + 13], 21, 1309151649);
            a = II(a, b, c, d, m[i + 4], 6, -145523070);
            d = II(d, a, b, c, m[i + 11], 10, -1120210379);
            c = II(c, d, a, b, m[i + 2], 15, 718787259);
            b = II(b, c, d, a, m[i + 9], 21, -343485551);
            a = a + aa >>> 0;
            b = b + bb >>> 0;
            c = c + cc >>> 0;
            d = d + dd >>> 0;
        }
        return crypt.endian([
            a,
            b,
            c,
            d
        ]);
    };
    // Auxiliary functions
    md5._ff = function(a, b, c, d, x, s, t) {
        var n = a + (b & c | ~b & d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
    };
    md5._gg = function(a, b, c, d, x, s, t) {
        var n = a + (b & d | c & ~d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
    };
    md5._hh = function(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
    };
    md5._ii = function(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
    };
    // Package private blocksize
    md5._blocksize = 16;
    md5._digestsize = 16;
    md5$1.exports = function(message, options) {
        if (message === undefined || message === null) throw new Error('Illegal argument ' + message);
        var digestbytes = crypt.wordsToBytes(md5(message, options));
        return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
    };
})();

var md5Exports = md5$1.exports;
var md5 = /*@__PURE__*/getDefaultExportFromCjs(md5Exports);

const ALL_DATABASES = new Map();
class Database {
    static open(player, dbName) {
        return new Database(player, dbName);
    }
    _syncDataFromScoreboard() {
        this.store.clear();
        each(this.objective.getParticipants(), (participant)=>{
            const data = deserialize(participant.displayName);
            const key = Object.keys(data)[0];
            const value = data[key];
            this.store.set(key, {
                value,
                participant
            });
        });
    }
    has(key) {
        return this.store.has(key);
    }
    async delete(key) {
        if (this.has(key)) {
            const { participant } = this.store.get(key);
            await asyncRun(()=>this.objective.removeParticipant(participant));
            this.store.delete(key);
            return true;
        }
        return false;
    }
    async clear() {
        await eachAsync(this.store, async ([, { participant }])=>await asyncRun(()=>this.objective.removeParticipant(participant)));
        this.store.clear();
    }
    get(key) {
        if (this.has(key)) return this.store.get(key).value;
    }
    async set(key, value) {
        await this.delete(key);
        const data = serialize({
            [key]: value
        }).replaceAll('"', "'");
        // FIXME: has ambiguity
        if (data.length > 32767) throw new RangeError("Database: Only accepts a string value less than 32767 characters.");
        await asyncRun(()=>this.objective.setScore(data, 1));
        this._syncDataFromScoreboard();
    }
    getAll() {
        const output = {};
        for (const [key, value] of this)output[key] = value;
        return output;
    }
    *entries() {
        for (const [key, { value }] of this.store.entries())yield [
            key,
            value
        ];
    }
    *keys() {
        for (const key of this.store.keys())yield key;
    }
    *values() {
        for (const { value } of this.store.values())yield value;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    constructor(player, dbName){
        this.store = new Map();
        const id = md5(`db:${dbName}_${player.id}`).slice(8, 24);
        this.id = id;
        this.objective = getOrAddObjective(id, `db:${dbName}`);
        // this.player = player
        // if (!(player instanceof Player)) this.fakePlayer = true
        this._syncDataFromScoreboard();
        ALL_DATABASES.set(id, this);
    }
}

class EventEmitter {
    on(eventName, listener) {
        if (isAsyncFunc(listener)) {
            const _eventName = `${eventName}.async`;
            if (this._events[_eventName]) this._events[_eventName].push(listener);
            else this._events[_eventName] = [
                listener
            ];
        } else {
            if (this._events[eventName]) this._events[eventName].push(listener);
            else this._events[eventName] = [
                listener
            ];
        }
        return this;
    }
    once(eventName, listener) {
        if (isAsyncFunc(listener)) {
            const _eventName = `${eventName}.async`;
            const _listener = async (...args)=>{
                await listener(...args);
                this.removeListener(_eventName, _listener);
            };
            if (this._events[_eventName]) this._events[_eventName].push(_listener);
            else this._events[_eventName] = [
                _listener
            ];
        } else {
            const _listener = (...args)=>{
                listener(...args);
                this.removeListener(eventName, _listener);
            };
            if (this._events[eventName]) this._events[eventName].push(_listener);
            else this._events[eventName] = [
                _listener
            ];
        }
        return this;
    }
    removeListener(eventName, listener) {
        if (this._events[eventName]) {
            const newListeners = [];
            each(this._events[eventName], (_listener)=>{
                if (_listener !== listener) newListeners.push(_listener);
            });
            this._events[eventName] = newListeners;
        }
        return this;
    }
    async emit(eventName, ...args) {
        if (this._events[eventName]) {
            each(this._events[eventName], (listener)=>listener(...args));
        }
        await this.asyncEmit(eventName, ...args);
    }
    async asyncEmit(eventName, ...args) {
        const _eventName = `${eventName}.async`;
        if (this._events[_eventName]) {
            await eachAsync(this._events[_eventName], async (listener)=>await listener(...args));
        }
    }
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    off(eventName, listener) {
        return this.removeListener(eventName, listener);
    }
    constructor(){
        this._events = {};
    }
}

class OptionItemRange {
    select(value) {
        if (this.selected !== value && this._includes(value)) {
            this.original = this.selected;
            this.selected = value;
            this.events.emit("selected", this.selected, this.original, this._player);
            this.events.emit("changed", this.selected, this.original, this._player);
            return true;
        }
        return false;
    }
    _includes(n) {
        return this.range.includes(n);
    }
    constructor({ name, description, range = [
        0,
        1,
        1
    ], defaultValue, events, reload, _player }){
        this.name = name;
        this.description = description;
        this.range = new NumberRange(...range);
        this.events = new EventEmitter();
        this.reload = reload;
        this._defaultValue = defaultValue;
        this._player = _player;
        if (events) each(events, (listener, eventName)=>this.events.on(eventName, listener));
        if (defaultValue !== undefined && this._includes(defaultValue)) this.selected = defaultValue;
        else this.selected = this.range.min;
        this.events.emit("inited", this.selected, _player);
        this.events.emit("changed", this.selected, undefined, _player);
    }
}

class OptionItemSelection {
    select(value) {
        if (this.selected !== value && this.hasVal(value)) {
            this.original = this.selected;
            this.selected = value;
            this.events.emit("selected", this.selected, this.original, this._player);
            this.events.emit("changed", this.selected, this.original, this._player);
            return true;
        }
        return false;
    }
    hasVal(name) {
        return this.values.has(name) || !this.values.size;
    }
    constructor({ name, description, values = [], defaultValue, events, reload, _player }){
        this.name = name;
        this.description = description;
        this.values = new Map(values.map((value)=>{
            if (value[0] === true && !value[1]) value[1] = "开启";
            else if (value[0] === false && !value[1]) value[1] = "关闭";
            return value;
        }));
        this.events = new EventEmitter();
        this.reload = reload;
        this._defaultValue = defaultValue;
        this._player = _player;
        if (events) each(events, (listener, eventName)=>this.events.on(eventName, listener));
        if (defaultValue !== undefined && this.hasVal(defaultValue)) this.selected = defaultValue;
        else if (values[0]) this.selected = values[0][0];
        this.events.emit("inited", this.selected, _player);
        this.events.emit("changed", this.selected, undefined, _player);
    }
}

class PlayerOption {
    addItem(opts) {
        if (opts.range) this.items[opts.name] = new OptionItemRange(opts);
        else if (opts.values) this.items[opts.name] = new OptionItemSelection(opts);
        return this;
    }
    async _syncToDB() {
        const data = this.getItemValMap();
        await eachAsync(data, async (value, name)=>{
            await this.db.set(name, value);
        });
        await eachAsync(this.db, async ([name, _])=>{
            if (!this.hasItem(name)) await this.db.delete(name);
        });
    }
    async _syncFromDB() {
        each(this.db, ([name, value])=>this.setItemVal(name, value, undefined, {
                syncFromDB: true
            }));
        await this._syncToDB();
    }
    async init() {
        this.addItem = undefined;
        await this._syncFromDB();
        return this.getItemValMap();
    }
    _getItem(name) {
        return this.items[name];
    }
    hasItem(name) {
        return !!this.items[name];
    }
    setItemVal(name, value, callback = (_, __, ___)=>{}, { syncFromDB = false } = {}) {
        const item = this._getItem(name);
        if (item) {
            const result = item.select(value);
            if (result) {
                if (!syncFromDB && item.reload) this.reload = true;
                callback(item.selected, item.original, this.getItemValMap());
            }
        }
        return this;
    }
    getItemVal(name) {
        const item = this._getItem(name);
        if (item) return item.selected;
    }
    getItemValMap() {
        const result = {};
        each(this.items, (_, name)=>{
            result[name] = this.getItemVal(name);
        });
        return result;
    }
    async done(parentDialog) {
        const handleDone = async ({ reply = true } = {})=>{
            await this._syncToDB();
            if (reply) this.player.sendMessage("设置选项修改成功");
        };
        if (this.reload) {
            this.reload = false;
            await Dialog.confirm({
                body: '你选择的项目更改后需要刷新脚本，请手动运行 "/reload" 命令。\n\n您也可以取消您的更改',
                target: this.player,
                onConfirm: async ()=>{
                    await handleDone({
                        reply: false
                    });
                // await Commands.asyncRun("reload")
                },
                onCancel: async ()=>{
                    await this._syncFromDB();
                    await this.showDialog(parentDialog);
                }
            });
        } else await handleDone();
    }
    async showDialog(parentDialog) {
        const form = new ModalFormData().title(`${this.name} 选项`);
        const nameMap = [];
        each(this.items, (item)=>{
            if (item instanceof OptionItemSelection) {
                const { name, description, values, selected } = item;
                if (values.size === 2 && values.get(true) && values.get(false)) {
                    const valuesMap = new Map();
                    each(values, ([e])=>valuesMap.set(e, e));
                    nameMap.push({
                        name,
                        valuesMap
                    });
                    form.toggle(description, selected);
                } else {
                    const valueArray = [
                        ...values
                    ];
                    const valuesMap = new Map();
                    each(valueArray, ([e], i)=>valuesMap.set(i, e));
                    nameMap.push({
                        name,
                        valuesMap
                    });
                    form.dropdown(description, valueArray.map((e)=>e[1]), valueArray.map((e)=>e[0]).findIndex((e)=>e === selected));
                }
            } else if (item instanceof OptionItemRange) {
                const { name, description, range, selected } = item;
                const valuesMap = new Map();
                each(range, (i)=>valuesMap.set(i, i));
                nameMap.push({
                    name,
                    valuesMap
                });
                form.slider(description, range.min, range.max, range.step, selected);
            }
        });
        const dialog = new Dialog({
            dialog: form,
            onClose: async ()=>{
                if (parentDialog) await parentDialog.show(this.player);
            },
            onSubmit: async (result)=>{
                each(result, (valueIndex, nameIndex)=>{
                    const { name, valuesMap } = nameMap[nameIndex];
                    const value = valuesMap.get(valueIndex);
                    this.setItemVal(name, value);
                });
                await this.done(parentDialog);
            }
        });
        await dialog.show(this.player);
    }
    constructor(player, name){
        this.items = {};
        this.name = name;
        this.db = Database.open(player, `option-manager:${name}`);
        this.player = player;
    }
}

class OptionNamespace {
    addItem(opts) {
        this._items.add(opts);
        return this;
    }
    applyPlayer(player) {
        if (this.players.has(player)) return this.players.get(player);
        const playerOpt = new PlayerOption(player, this.name);
        each(this._items, (item)=>{
            item._player = player;
            playerOpt.addItem(item);
        });
        this.players.set(player, playerOpt);
        return playerOpt;
    }
    async applyMainPlayer() {
        const player = await waitForFirstPlayerInitialSpawn();
        return this.applyPlayer(player);
    }
    async init() {
        const valueMap = new Map();
        await eachAsync(this.players, async ([player, playerOpt])=>{
            const result = await playerOpt.init();
            valueMap.set(player, result);
        });
        this.applyPlayer = undefined;
        return valueMap;
    }
    getPlayer(player) {
        return this.players.get(player);
    }
    constructor(name){
        this.players = new Map();
        this._items = new Set();
        this.name = name;
    }
}

class OptionManager {
    registerNamesapace(name) {
        const namespaces = new OptionNamespace(name);
        this.namespaces.set(name, namespaces);
        return namespaces;
    }
    getNamesapace(name) {
        return this.namespaces.get(name);
    }
    async showDialog(player) {
        const form = new ActionFormData().title("设置选项").body("选择要设置的模块：");
        const nameMap = [];
        each(this.namespaces, ([name])=>{
            nameMap.push(name);
            form.button(name) // TODO name -> desc
            ;
        });
        const dialog = new Dialog({
            dialog: form,
            onSelect: async (selection)=>{
                const name = nameMap[selection];
                await this.getNamesapace(name).getPlayer(player).showDialog(dialog);
            }
        });
        await dialog.show(player);
    }
    constructor(){
        this.namespaces = new Map();
    }
}

const optionManager = new OptionManager();

Commands.register("!", "option", async (argv, sender)=>{
    switch(argv[1]){
        case "dialog":
        case "-d":
        case undefined:
            {
                // TODO argv[2] -> namespace
                await asyncRun(()=>optionManager.showDialog(sender));
                break;
            }
        default:
            {
                throw errorHandler("未知的子命令", sender);
            }
    }
});

const option$3 = optionManager.registerNamesapace("better-door").addItem({
    name: "door",
    description: "允许双开门",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: true,
    events: {
        changed: (selected, original)=>console.warn("better-door:door -> from", original, "to", selected)
    }
}).addItem({
    name: "trapdoor",
    description: "允许多开活板门",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: false,
    events: {
        changed: (selected, original)=>console.warn("better-door:trapdoor -> from", original, "to", selected)
    }
}).addItem({
    name: "max_trapdoor_length",
    description: "允许多开活板门的最大距离",
    range: [
        1,
        32
    ],
    defaultValue: 3,
    events: {
        changed: (selected, original)=>console.warn("better-door:max_trapdoor_length -> from", original, "to", selected)
    }
}).addItem({
    name: "should_be_the_same_type",
    description: "是否需要是同种门",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: true,
    events: {
        changed: (selected, original)=>console.warn("better-door:should_be_the_same_type -> from", original, "to", selected)
    }
});

const setupListener$1 = ()=>world.beforeEvents.itemUseOn.subscribe((event)=>{
        const { block, source: player } = event;
        const playerOption = option$3.getPlayer(player);
        const shouldBeTheSameType = playerOption.getItemVal("should_be_the_same_type");
        if (DoorBlock.match(block) && playerOption.getItemVal("door")) {
            event.cancel = true;
            // @ts-ignore
            const doors = DoorBlock.wrap(block).getRelated({
                shouldBeTheSameType
            });
            asyncRun(()=>{
                if (doors[0].opened) each(doors, (_)=>_.close());
                else each(doors, (_)=>_.open());
            }).catch(BetterConsole.error);
        } else if (TrapdoorBlock.match(block) && playerOption.getItemVal("trapdoor")) {
            event.cancel = true;
            const maxLength = playerOption.getItemVal("max_trapdoor_length");
            // @ts-ignore
            const trapdoors = TrapdoorBlock.wrap(block).getRelated(player, {
                maxLength,
                shouldBeTheSameType
            });
            asyncRun(()=>{
                if (trapdoors[0].opened) each(trapdoors, (_)=>_.close());
                else each(trapdoors, (_)=>_.open());
            }).catch(BetterConsole.error);
        }
    });

option$3.applyMainPlayer().then(()=>each(world.getAllPlayers(), (player)=>option$3.applyPlayer(player))).then(()=>option$3.init()).then(()=>setupListener$1()).catch(BetterConsole.error);

const globalDB = new Database({
    id: "global"
}, "scoreboard-statistic-global");
const ALL_PLAYER_DATABASES$1 = new Map();
class EventDB {
    // 此次因为有 events 这个运行时存储项，
    // 而不能多次 construct，
    // 故使用此方法将实例储存到 ALL_PLAYER_DATABASES 中
    static init(player) {
        const db = new EventDB(player);
        ALL_PLAYER_DATABASES$1.set(player, db);
        return db;
    }
    async addParticipated(objectiveId) {
        const participated = this.getParticipated();
        participated.add(objectiveId);
        await this.db.set("__participated__", participated);
    }
    getParticipated() {
        return new Set(this.db.get("__participated__") ?? []);
    }
    setEvents(objectiveId, events) {
        this.events.set(objectiveId, events);
    }
    getEvents(objectiveId) {
        return this.events.get(objectiveId);
    }
    async add(objectiveId, events) {
        await this.addParticipated(objectiveId);
        this.setEvents(objectiveId, events);
    }
    has(objectiveId) {
        return this.events.has(objectiveId) && this.getParticipated().has(objectiveId);
    }
    async delete(objectiveId) {
        const participated = this.getParticipated();
        if (participated.has(objectiveId)) {
            participated.delete(objectiveId);
            await this.db.set("__participated__", participated);
            this.events.delete(objectiveId);
            return true;
        }
    }
    async clear() {
        await this.db.clear();
        this.events.clear();
    }
    constructor(player){
        this.events = new Map();
        this.db = new Database(player, "scoreboard-statistic-player");
        this.player = player;
    }
}

const option$2 = optionManager.registerNamesapace("scoreboard-statistic").addItem({
    name: "enable_creative",
    description: "允许统计创造模式下的行为",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: true,
    events: {
        changed: (selected, original)=>console.warn("scoreboard-statistic:enable_creative -> from", original, "to", selected)
    }
}).addItem({
    name: "enable_cancel_out",
    description: "对部分统计项启用抵消",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: false,
    events: {
        changed: (selected, original)=>console.warn("scoreboard-statistic:enable_cancel_out -> from", original, "to", selected)
    }
}).addItem({
    name: "enable_confirm_dialog",
    description: "启用删除记分板时的警告",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: true,
    events: {
        changed: (selected, original)=>console.warn("scoreboard-statistic:enable_confirm_dialog -> from", original, "to", selected)
    }
}).addItem({
    name: "auto_start",
    description: "添加记分板后是否自动开始统计",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: true,
    events: {
        changed: (selected, original)=>console.warn("scoreboard-statistic:auto_start -> from", original, "to", selected)
    }
});

var killed = (({ player, target, callback })=>({
        events: {
            entityDie: {
                option: {
                    entityTypes: [
                        target
                    ]
                },
                listener (event) {
                    const cause = event.damageSource.cause;
                    const source = event.damageSource.damagingEntity;
                    if (cause === EntityDamageCause.entityAttack && source.id === player.id) callback({
                        type: "increase",
                        value: 1
                    });
                }
            }
        }
    }));

var killed_by = (({ player, target, callback })=>({
        events: {
            entityDie: {
                option: {
                    entities: [
                        player
                    ]
                },
                listener (event) {
                    const cause = event.damageSource.cause;
                    const source = event.damageSource.damagingEntity;
                    if (cause === EntityDamageCause.entityAttack && source.typeId === target) callback({
                        type: "increase",
                        value: 1
                    });
                }
            }
        }
    }));

var killed_for = (({ player, target, callback })=>({
        events: {
            entityDie: {
                option: {
                    entities: [
                        player
                    ]
                },
                listener (event) {
                    const cause = `minecraft:${event.damageSource.cause}`;
                    if (cause === target) callback({
                        type: "increase",
                        value: 1
                    });
                }
            }
        }
    }));

var mined = (({ player, target, callback })=>({
        events: {
            playerBreakBlock: {
                listener (event) {
                    const blockPermutation = event.brokenBlockPermutation;
                    const source = event.player;
                    if (source.id === player.id && blockPermutation.type.id === target) callback({
                        type: "increase",
                        value: 1
                    });
                }
            },
            playerPlaceBlock: {
                listener (event) {
                    const block = event.block;
                    const source = event.player;
                    if (source.id === player.id && block.typeId === target) callback({
                        type: "decrease",
                        value: 1
                    });
                }
            }
        }
    }));

var placed = (({ player, target, callback })=>({
        events: {
            playerBreakBlock: {
                listener (event) {
                    const blockPermutation = event.brokenBlockPermutation;
                    const source = event.player;
                    if (source.id === player.id && blockPermutation.type.id === target) callback({
                        type: "decrease",
                        value: 1
                    });
                }
            },
            playerPlaceBlock: {
                listener (event) {
                    const block = event.block;
                    const source = event.player;
                    if (source.id === player.id && block.typeId === target) callback({
                        type: "increase",
                        value: 1
                    });
                }
            }
        }
    }));

// import custom from "./custom/index"
const types = {
    // custom
    // TODO
    // "minecraft:custom": custom, custom,
    // mob
    "minecraft:killed": killed,
    killed,
    "minecraft:killed_by": killed_by,
    killed_by,
    "minecraft:killed_for": killed_for,
    killed_for,
    // block
    "minecraft:mined": mined,
    mined,
    "minecraft:placed": placed,
    placed
};

var deathCount = (({ player, callback })=>({
        events: {
            entityDie: {
                option: {
                    entities: [
                        player
                    ]
                },
                listener () {
                    callback({
                        type: "increase",
                        value: 1
                    });
                }
            }
        }
    }));

var health = (({ player, callback })=>({
        events: {
            entityHealthChanged: {
                option: {
                    entities: [
                        player
                    ]
                },
                listener (event) {
                    callback({
                        type: "reset",
                        value: event.newValue
                    });
                }
            },
            playerSpawn: {
                listener () {
                    callback({
                        type: "reset",
                        value: 20
                    });
                }
            }
        }
    }));

var playerKillCount = (({ player, callback })=>killed({
        player,
        target: "minecraft:player",
        callback
    }));

var totalKillCount = (({ player, callback })=>({
        events: {
            entityDie: {
                listener (event) {
                    const cause = event.damageSource.cause;
                    const source = event.damageSource.damagingEntity;
                    if (cause === EntityDamageCause.entityAttack && source.id === player.id) callback({
                        type: "increase",
                        value: 1
                    });
                }
            }
        }
    }));

// @ts-ignore
var CRITERIA = new Map([
    ...Object.entries(types),
    [
        "deathCount",
        deathCount
    ],
    [
        "playerKillCount",
        playerKillCount
    ],
    [
        "totalKillCount",
        totalKillCount
    ],
    [
        "health",
        health
    ]
]);

let Handler$1 = class Handler {
    async add({ objectiveId, criteria, displayName = objectiveId }) {
        if (world.scoreboard.getObjective(objectiveId)) return {
            code: 0,
            message: "DUPLICATE_OBJECTIVE"
        };
        const [criteriaType] = parseCriteria(criteria);
        if (!CRITERIA.get(criteriaType)) return {
            code: 0,
            message: "UNKNOWN_CRITERIA"
        };
        await asyncRun(()=>{
            const objective = world.scoreboard.addObjective(objectiveId, displayName);
            world.scoreboard.setObjectiveAtDisplaySlot(DisplaySlotId.Sidebar, {
                objective,
                sortOrder: ObjectiveSortOrder.Ascending
            });
            if (!objective.hasParticipant(this.player)) {
                // TODO: 或许放到 start 里更合理
                // 如果该玩家不存在任何一个记分板中，直接 setScore(this.player) 会报错
                // 所以这里用命令设置一下初始分数
                // objective.setScore(this.player, 0)
                this.player.runCommand(`scoreboard players set @s ${objectiveId} 0`);
            }
        });
        await globalDB.set(objectiveId, criteria);
        return {
            code: 1
        };
    }
    async remove({ objectiveId }) {
        if (!globalDB.get(objectiveId)) return false;
        await asyncRun(()=>world.scoreboard.removeObjective(objectiveId));
        await globalDB.delete(objectiveId);
        return true;
    }
    async start({ objectiveId, criteria = globalDB.get(objectiveId) }) {
        if (this.playerDB.has(objectiveId)) return false;
        const objective = getOrAddObjective(objectiveId);
        const [criteriaType, criteriaName] = parseCriteria(criteria);
        const setupTigger = CRITERIA.get(criteriaType);
        const tigger = setupTigger({
            player: this.player,
            target: criteriaName,
            callback: (result)=>{
                if (// @ts-ignore
                !WrappedPlayer.wrap(this.player).testGameMode(GameMode.creative) || this.playerOption.getItemVal("enable_creative")) {
                    switch(result.type){
                        case "decrease":
                            {
                                if (this.playerOption.getItemVal("enable_cancel_out")) objective.setScore(this.player, objective.getScore(this.player) - result.value);
                                break;
                            }
                        case "reset":
                            {
                                objective.setScore(this.player, result.value);
                                break;
                            }
                        default:
                            {
                                // TODO: scoreboard wrapper #addScore()
                                objective.setScore(this.player, objective.getScore(this.player) + result.value);
                            }
                    }
                }
            }
        });
        await eachAsync(tigger.events, async ({ option: subscribeOption, listener }, eventName)=>{
            if (subscribeOption) await asyncRun(()=>world.afterEvents[eventName].subscribe(listener, subscribeOption));
            else await asyncRun(()=>world.afterEvents[eventName].subscribe(listener)) // 为什么多传参数还报错啊啊啊啊啊啊啊！！！
            ;
        });
        await this.playerDB.add(objectiveId, tigger.events);
        return true;
    }
    async stop({ objectiveId }) {
        if (!this.playerDB.has(objectiveId)) return false;
        const events = this.playerDB.getEvents(objectiveId);
        await eachAsync(events, async ({ listener }, eventName)=>{
            await asyncRun(()=>world.afterEvents[eventName].unsubscribe(listener));
        });
        await this.playerDB.delete(objectiveId);
        return true;
    }
    constructor(player){
        this.player = player;
        this.playerOption = option$2.getPlayer(player);
        this.playerDB = ALL_PLAYER_DATABASES$1.get(player);
    }
};
function parseCriteria(criteria) {
    return criteria.split(":").map((e)=>e.replace(".", ":")).map((e, i)=>{
        if (i === 0) return e;
        return e.match(/^(.+)\:/) ? e : `minecraft:${e}`;
    });
}

async function command(argv, sender) {
    const playerOption = option$2.getPlayer(sender);
    const handler = new Handler$1(sender);
    const objectiveId = argv[2];
    switch(argv[1]){
        case "add":
            {
                const [, , , criteria, displayName] = argv;
                if (!objectiveId) throw errorHandler("objectiveId 是必须的", sender);
                if (!criteria) throw errorHandler("criteria 是必须的", sender);
                if (!playerOption.getItemVal("enable_creative")) sender.sendMessage("注意：当前设置不会统计创造模式下的行为");
                const result = await handler.add({
                    objectiveId,
                    criteria,
                    displayName
                });
                if (result.code) sender.sendMessage(`成功添加记分板 "${displayName}" (${objectiveId}) 使用 "${criteria}"`);
                else {
                    switch(result.message){
                        case "DUPLICATE_OBJECTIVE":
                            {
                                throw errorHandler(`添加失败：记分板 ${objectiveId} 已存在`, sender);
                            }
                        case "UNKNOWN_CRITERIA":
                            {
                                throw errorHandler(`添加失败：未知的准则 ${criteria}`, sender);
                            }
                    }
                }
                if (playerOption.getItemVal("auto_start")) {
                    const startResult = await handler.start({
                        objectiveId,
                        criteria
                    });
                    if (startResult) sender.sendMessage(`已自动开启您在 ${displayName} 上的统计`);
                }
                break;
            }
        case "remove":
        case "rm":
        case "-r":
            {
                async function _remove() {
                    const result = await handler.remove({
                        objectiveId
                    });
                    if (result) sender.sendMessage(`删除成功 ${objectiveId}`);
                    else throw errorHandler(`移除失败：记分板 ${objectiveId} 不存在或不是统计用记分板`, sender);
                }
                if (playerOption.getItemVal("enable_confirm_dialog")) await Dialog.confirm({
                    body: `是否清除记分板 ${objectiveId} 上的统计数据，你将永远失去它们`,
                    target: sender,
                    onConfirm: _remove
                });
                else await _remove();
                break;
            }
        case "stop":
            {
                const result = await handler.stop({
                    objectiveId
                });
                if (result) sender.sendMessage(`已暂停您在 ${objectiveId} 上的统计`);
                else throw errorHandler(`暂停失败：您可能没有开启您在记分板 ${objectiveId} 上的统计，或该记分板不存在`, sender);
                break;
            }
        case "start":
            {
                const result = await handler.start({
                    objectiveId
                });
                if (result) sender.sendMessage(`已开启您在 ${objectiveId} 上的统计`);
                else throw errorHandler(`开启失败：您可能已经开启您在记分板 ${objectiveId} 上的统计，或该记分板不存在`, sender);
                break;
            }
        case "option":
        case "opt":
        case "-o":
            {
                await asyncRun(()=>playerOption.showDialog());
                break;
            }
        default:
            {
                throw errorHandler(`未知的子命令 ${argv[1]}`, sender);
            }
    }
}

option$2.applyMainPlayer().then(()=>each(world.getAllPlayers(), (player)=>option$2.applyPlayer(player))).then(()=>option$2.init()).then(async ()=>{
    await eachAsync(option$2.players, async ([player])=>{
        // 将所有玩家的数据库实例化并储存在 ALL_PLAYER_DATABASES 中
        const db = EventDB.init(player);
        const handler = new Handler$1(player);
        const participated = db.getParticipated();
        // reload 后运行时存储 events 为空，
        // 并且 listener 也都失效，
        // 故重新订阅事件
        await db.clear();
        await eachAsync(participated, async (objectiveId)=>{
            const result = await handler.start({
                objectiveId
            });
            if (result) player.sendMessage(`已重启您在记分板 ${objectiveId} 上的统计`);
        });
    });
    Commands.register("!", "statistic", command);
}).catch(BetterConsole.error);

const ALL_PLAYER_DATABASES = new Map();
class TpxDB {
    static init(player) {
        const db = new TpxDB(player);
        ALL_PLAYER_DATABASES.set(player, db);
        return db;
    }
    async set({ name, disposable, force }) {
        const info = new LocationInfo(this.player);
        const handleSet = async ()=>{
            await this.db.set(name, {
                info: info.textify(),
                disposable
            });
            return info;
        };
        if (!force && this.db.has(name)) {
            return await Dialog.confirm({
                body: `名称 ${name} 已被占用，是否覆盖？`,
                target: this.player,
                // @ts-ignore
                onConfirm: async ()=>await handleSet()
            });
        }
        return await handleSet();
    }
    async get(name) {
        if (!this.db.has(name)) return;
        const { info: data, disposable } = this.db.get(name);
        if (disposable) await this.db.delete(name);
        if (data) return new LocationInfo(data);
    }
    async remove(name) {
        if (!this.db.has(name)) return false;
        return await Dialog.confirm({
            body: `是否删除 ${name} `,
            target: this.player,
            // @ts-ignore
            onConfirm: async ()=>await this.db.delete(name)
        });
    }
    getAll() {
        const output = [];
        each(this.db, ([name, { info: data, disposable }])=>{
            const info = new LocationInfo(data);
            output.push({
                name,
                info,
                disposable,
                text: `${name} (${info})${disposable ? " [一次性]" : ""}`
            });
        });
        return output;
    }
    constructor(player){
        this.db = Database.open(player, "tpx");
        this.player = player;
    }
}

async function afterEntityDieCallback(event) {
    const player = event.deadEntity;
    const handler = new Handler(player);
    await handler.set({
        name: "__death__",
        option: {
            disposable: true,
            force: true
        }
    });
}
const option$1 = optionManager.registerNamesapace("tpx").addItem({
    name: "auto_back_point",
    description: "允许使用 tpx 传送时自动添加返回点",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: true,
    events: {
        changed: (selected, original)=>console.warn("tpx:auto_back_point -> from", original, "to", selected)
    }
}).addItem({
    name: "back_after_death",
    description: "允许死亡时自动添加死亡点",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: true,
    events: {
        changed: (selected, original)=>{
            console.warn("tpx:back_after_death -> from", original, "to", selected);
            if (selected) world.afterEvents.entityDie.subscribe(afterEntityDieCallback, {
                entityTypes: [
                    "minecraft:player"
                ]
            });
            else world.afterEvents.entityDie.unsubscribe(afterEntityDieCallback);
        }
    }
}).addItem({
    name: "back_cmd",
    description: "允许使用独立的 back 命令",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: false,
    reload: true,
    events: {
        changed: (selected, original)=>console.warn("tpx:back_cmd -> from", original, "to", selected)
    }
}).addItem({
    name: "home_cmd",
    description: "允许使用独立的 home 命令",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: false,
    reload: true,
    events: {
        changed: (selected, original)=>console.warn("tpx:home_cmd -> from", original, "to", selected)
    }
});

class Handler {
    async set({ name = "default", option = {} }) {
        const info = await this.playerDB.set(Object.assign({
            name
        }, option));
        if (name !== "__back__" && name !== "__death__") return {
            info
        };
    }
    async remove({ name = "default" }) {
        return await this.playerDB.remove(name);
    }
    async teleport({ name = "default" }) {
        const info = await this.playerDB.get(name);
        if (info) {
            if (this.playerOption.getItemVal("auto_back_point") && name !== "__death__") {
                await this.set({
                    name: "__back__",
                    option: {
                        disposable: true,
                        force: true
                    }
                });
            }
            await asyncRun(()=>this.player.teleport(info.location, {
                    dimension: info.dimension,
                    checkForBlocks: false,
                    keepVelocity: false
                }));
            return {
                info
            };
        }
    }
    async tryTeleport({ names = [] }) {
        for (const name of names){
            const result = await this.teleport({
                name
            });
            if (result) return result;
        }
    }
    list() {
        const datas = this.playerDB.getAll().map(({ text })=>text);
        if (datas.length) return {
            msg: datas
        };
    }
    constructor(player){
        this.player = player;
        this.playerOption = option$1.getPlayer(player);
        this.playerDB = ALL_PLAYER_DATABASES.get(player);
    }
}

const SUB_COMMANDS = [
    "set",
    "-s",
    "remove",
    "rm",
    "-r",
    "back",
    "bk",
    "-b",
    "list",
    "ls",
    "-l",
    "help",
    "-h",
    "option",
    "opt",
    "-o"
];
async function tpxCommand(argv, sender) {
    const name = argv[2] ?? "default";
    const handler = new Handler(sender);
    switch(argv[1]){
        case "set":
        case "-s":
            {
                if (SUB_COMMANDS.includes(name) || name === "__back__") throw errorHandler(`添加失败：不能使用 ${name} 作为名称`, sender);
                const result = await handler.set({
                    name,
                    option: {
                        disposable: argv[3] === "true" ? true : argv[3] === "false" ? false : null
                    }
                });
                if (result) sender.sendMessage(`成功设置 ${name} 在 ${result.info}`);
                break;
            }
        case "remove":
        case "rm":
        case "-r":
            {
                const result = await handler.remove({
                    name
                });
                if (result === true) sender.sendMessage(`成功删除 ${name}`);
                else if (result === false) throw errorHandler(`删除失败：未找到 ${name}`, sender);
                break;
            }
        case "back":
        case "bk":
        case "-b":
            {
                const result = await handler.tryTeleport({
                    names: [
                        "__death__",
                        "__back__"
                    ]
                });
                if (result) sender.sendMessage(`已返回到 ${result.info}`);
                else throw errorHandler("传送失败：未找到返回点", sender);
                break;
            }
        case "list":
        case "ls":
        case "-l":
            {
                const result = handler.list();
                if (result) {
                    result.msg.unshift("您的传送点有：");
                    sender.sendMessage(result.msg.join("\n- "));
                } else sender.sendMessage("您目前没有传送点");
                break;
            }
        case "help":
        case "-h":
            {
                // TODO command-parser
                sender.sendMessage("制作中...");
                break;
            }
        case "option":
        case "opt":
        case "-o":
            {
                await asyncRun(()=>option$1.getPlayer(sender).showDialog());
                break;
            }
        default:
            {
                const result = await handler.teleport({
                    name: argv[1]
                });
                if (result) sender.sendMessage(`已传送到 ${result.info}`);
                else throw errorHandler(`传送失败：未找到传送点 ${argv[1]}`, sender);
            }
    }
}
async function backCommand(_, sender) {
    if (option$1.getPlayer(sender).getItemVal("back_cmd")) await Commands.asyncRun("!tpx back", sender);
    else sender.sendMessage("您未启用该命令");
}
async function homeCommand(argv, sender) {
    if (option$1.getPlayer(sender).getItemVal("home_cmd")) {
        switch(argv[1]){
            case "set":
                {
                    await Commands.asyncRun("!tpx set __home__", sender);
                    break;
                }
            default:
                {
                    await Commands.asyncRun("!tpx __home__", sender);
                }
        }
    } else sender.sendMessage("您未启用该命令");
}

option$1.applyMainPlayer().then(()=>each(world.getAllPlayers(), (player)=>option$1.applyPlayer(player))).then(()=>option$1.init()).then((optMap)=>{
    // 将所有玩家的数据库实例化并储存在 ALL_PLAYER_DATABASES 中
    // 同时避免在 beforeEvent 中构建导致的 read-only mode 问题
    const players = optMap.keys();
    each(players, (player)=>TpxDB.init(player));
    Commands.register("!", "tpx", tpxCommand);
    const values = [
        ...optMap.values()
    ];
    if (values.some(({ back_cmd })=>back_cmd)) Commands.register("!", "back", backCommand);
    if (values.some(({ home_cmd })=>home_cmd)) Commands.register("!", "home", homeCommand);
}).catch(BetterConsole.error);

const ENABLE_BLOCKS = new TypeGroup([
    ...LOGS,
    ...STEMS,
    ...ORES,
    "minecraft:obsidian",
    "minecraft:ancient_debris",
    "minecraft:amethyst_block"
]);

const option = optionManager.registerNamesapace("vein-mining").addItem({
    name: "condition",
    description: "触发条件",
    values: [
        [
            "off",
            "关闭"
        ],
        [
            "always",
            "总是"
        ],
        [
            "sneaking",
            "仅潜行时"
        ]
    ],
    defaultValue: "sneaking",
    events: {
        changed: (selected, original)=>console.warn("vein-mining:tigger -> from", original, "to", selected)
    }
}).addItem({
    name: "max_amount",
    description: "最多检测的方块数量（并非最终挖掘的方块数）",
    range: [
        8,
        128
    ],
    defaultValue: 64,
    events: {
        changed: (selected, original)=>console.warn("vein-mining:enable_edge -> from", original, "to", selected)
    }
}).addItem({
    name: "enable_stone",
    description: "允许连锁挖掘岩石类方块（石头、深板岩）",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: false,
    events: {
        changed: (selected, original)=>console.warn("vein-mining:enable_stone -> from", original, "to", selected)
    }
}).addItem({
    name: "auto_collection",
    description: "自动收集掉落物及经验（绕过经验修补）",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: false,
    events: {
        changed: (selected, original)=>console.warn("vein-mining:auto_collect_drops -> from", original, "to", selected)
    }
}).addItem({
    name: "prevent_tool_destruction",
    description: "防止工具耐久耗尽",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: false,
    events: {
        changed: (selected, original)=>console.warn("vein-mining:prevent_tool_destruction -> from", original, "to", selected)
    }
}).addItem({
    name: "enable_edge",
    description: "是否检测仅棱相连的方块",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: false,
    events: {
        changed: (selected, original)=>console.warn("vein-mining:enable_edge -> from", original, "to", selected)
    }
}).addItem({
    name: "enable_diagonal",
    description: "是否检测仅角相连的方块",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: false,
    events: {
        changed: (selected, original)=>console.warn("vein-mining:enable_diagonal -> from", original, "to", selected)
    }
});

const setupListener = ()=>world.afterEvents.playerBreakBlock.subscribe((event)=>{
        const basicBlock = new WrappedBlock(event.block);
        const blockTypeId = event.brokenBlockPermutation.type.id;
        const player = new WrappedPlayer(event.player);
        const playerOption = option.getPlayer(event.player);
        let enableBlocks = ENABLE_BLOCKS;
        if (playerOption.getItemVal("enable_stone")) enableBlocks = ENABLE_BLOCKS.clone().add(...STONES);
        player.useMainHandItem(async (mainHandItem)=>{
            if (!mainHandItem || !enableBlocks.has(blockTypeId) || !WrappedBlock.prototype.canBeDugBy.call({
                typeId: blockTypeId
            }, mainHandItem.typeId) || playerOption.getItemVal("condition") === "off" || playerOption.getItemVal("condition") === "sneaking" && !player.isSneaking) return mainHandItem;
            const blockList = getRelatedBlocks(playerOption, basicBlock, blockTypeId);
            const wrappedItem = ItemStackWithDurability.tryWrap(mainHandItem) ?? new WrappedItemStack(mainHandItem);
            let totalDamage = 0;
            const totalItems = [];
            let totalXp = 0;
            while(blockList.size > 0 && (!playerOption.getItemVal("prevent_tool_destruction") || playerOption.getItemVal("prevent_tool_destruction") && totalDamage < // @ts-ignore
            (wrappedItem.durability ?? Number.POSITIVE_INFINITY))){
                const block = blockList.shift();
                const result = await asyncRun(()=>block.breakBy(mainHandItem));
                totalDamage += result.getTotalDamage();
                if (playerOption.getItemVal("auto_collection")) {
                    each(result.drops, (drop)=>{
                        if (drop.xp) totalXp += drop.xp;
                        totalItems.push(drop);
                    });
                } else {
                    result.spawnDrops();
                }
            }
            if (playerOption.getItemVal("auto_collection")) {
                each(totalItems, ({ itemId, amount })=>player.inventory.addItem(new ItemStack(itemId, amount)));
                player.addExperience(totalXp);
            }
            if (wrappedItem instanceof ItemStackWithDurability) wrappedItem.applyDamage(totalDamage);
            // @ts-ignore
            return wrappedItem._item;
        }).catch(BetterConsole.error);
    });
function getNeighbourBlocks(playerOption, basicBlock, blockTypeId) {
    const offsets = [
        new BlockLocation(1, 0, 0),
        new BlockLocation(-1, 0, 0),
        new BlockLocation(0, 0, 1),
        new BlockLocation(0, 0, -1),
        new BlockLocation(0, 1, 0),
        new BlockLocation(0, -1, 0)
    ];
    if (playerOption.getItemVal("enable_edge")) {
        offsets.push(new BlockLocation(1, 1, 0), new BlockLocation(1, -1, 0), new BlockLocation(-1, 1, 0), new BlockLocation(-1, -1, 0), new BlockLocation(0, 1, 1), new BlockLocation(0, -1, 1), new BlockLocation(0, 1, -1), new BlockLocation(0, -1, -1), new BlockLocation(1, 0, 1), new BlockLocation(1, 0, -1), new BlockLocation(-1, 0, 1), new BlockLocation(-1, 0, -1));
    }
    if (playerOption.getItemVal("enable_diagonal")) {
        offsets.push(new BlockLocation(-1, -1, -1), new BlockLocation(-1, 1, -1), new BlockLocation(-1, -1, 1), new BlockLocation(-1, 1, 1), new BlockLocation(1, -1, -1), new BlockLocation(1, 1, -1), new BlockLocation(1, -1, 1), new BlockLocation(1, 1, 1));
    }
    const list = new BlockList();
    each(offsets, (offset)=>{
        const block = basicBlock.getOffsetBlock(offset);
        if (block.typeId === blockTypeId) list.add(block);
    });
    return list;
}
function getRelatedBlocks(playerOption, basicBlock, blockTypeId) {
    const maxAmount = playerOption.getItemVal("max_amount");
    const list = new BlockList();
    list.add(...getNeighbourBlocks(playerOption, basicBlock, blockTypeId));
    let previousSize = 0;
    let currentSize = list.size;
    while(currentSize < maxAmount && currentSize - previousSize > 0){
        for (const block of list){
            list.add(...getNeighbourBlocks(playerOption, block, blockTypeId));
            previousSize = currentSize;
            currentSize = list.size;
            if (currentSize >= maxAmount) break;
        }
    }
    return list;
}

option.applyMainPlayer().then(()=>each(world.getAllPlayers(), (player)=>option.applyPlayer(player))).then(()=>option.init()).then(()=>setupListener()).catch(BetterConsole.error);
//# sourceMappingURL=index.ts.map
