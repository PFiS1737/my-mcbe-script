/*!
 * my-mcbe-script-scoreboard-statistic.js v0.0.0 (https://github.com/PFiS1737/my-mcbe-script#readme)
 * Copyright 2022-2024 PFiS1737
 * Licensed under MIT
 *
 * This file is automatically generated, please do not change it.
 */
import { world, MinecraftDimensionTypes, Dimension, Entity, system, GameMode, EntityDamageCause, DisplaySlotId, ObjectiveSortOrder } from '@minecraft/server';
import require$$0 from 'crypto';
import { MessageFormData, FormCancelationReason, ModalFormResponse, MessageFormResponse, ActionFormResponse, ModalFormData, ActionFormData } from '@minecraft/server-ui';

class BetterConsole {
    static error(err) {
        console.error(`${err}\n${err.stack}`);
    }
}

function each(target, callbackfn, thisArg) {
    if (Array.isArray(target)) target.forEach(callbackfn, thisArg);
    else if (target?.[Symbol.iterator]) for (const item of target)callbackfn.call(thisArg, item, target);
    else if (typeof target === "object") each(Object.keys(target), (key, i)=>callbackfn.call(thisArg, target[key], key, i, target));
}
async function eachAsync(target, asyncfn, thisArg) {
    if (Array.isArray(target)) for(let i = 0; i < target.length; i++)await asyncfn.call(thisArg, target[i], i, target);
    else if (target?.[Symbol.iterator]) for (const item of target)await asyncfn.call(thisArg, item, target);
    else if (typeof target === "object") await eachAsync(Object.keys(target), async (key, i)=>await asyncfn.call(thisArg, target[key], key, i, target));
}
function safeEval(code, context = {}) {
    const fn = new Function(...Object.keys(context), `return ${code}`);
    return fn(...Object.values(context));
}
function deserialize(str) {
    try {
        return JSON.parse(str);
    } catch (err) {
        // console.warn(`Could not use \`JSON.parse()\` to deserialise the string, trying \`safeEval()\`.`, { string: str })
        return safeEval(`(${str})`);
    }
}
function isAsyncFunc(func) {
    return func[Symbol.toStringTag] === "AsyncFunction";
}

const overworld = world.getDimension(MinecraftDimensionTypes.overworld);
const CUSTOM_COMMAND_SET = new Set();
class Commands {
    static run(commandString, target = overworld) {
        // @ts-ignore
        if (target instanceof Dimension || target instanceof Entity) return target.runCommand(commandString);
        throw new TypeError("Target must be Entity or Dimension.");
    }
    static async asyncRun(commandString, target = overworld) {
        // @ts-ignore
        if (target instanceof Dimension || target instanceof Entity) {
            const customCommands = [
                ...CUSTOM_COMMAND_SET
            ].filter(({ regex })=>regex.test(commandString)).map((e)=>e.runner);
            if (customCommands.length) await eachAsync(customCommands, async (runner)=>await runner(commandString, target));
            else return await target.runCommandAsync(commandString);
        } else throw new TypeError("Target must be Entity or Dimension.");
    }
    static register(prefix, command, /* grammar, */ callback) {
        if (prefix.startsWith("/")) throw new Error("Unable to register slash commands.");
        const regex = new RegExp(`^${prefix}${command}( |$)`);
        const runner = async (commandString, target)=>{
            // callback(new Parser(commandString, grammar), target)
            const argv = commandString.split(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g).filter((e)=>e.trim().length > 0);
            await callback(argv, target);
        };
        CUSTOM_COMMAND_SET.add({
            regex,
            runner
        });
        world.beforeEvents.chatSend.subscribe((event)=>{
            if (regex.test(event.message)) {
                event.cancel = true;
                runner(event.message, event.sender).catch(BetterConsole.error);
            }
        });
    }
}

function round(n) {
    if (n >= 0) return Math.round(n);
    return n % 0.5 === 0 ? Math.floor(n) : Math.round(n);
}
function equals(a, b, epsilon = 0.000001) {
    return Math.abs(a - b) <= epsilon * Math.max(1, Math.abs(a), Math.abs(b));
}
function range(from, to, step = 1) {
    const output = [];
    for(let i = from; i < to; i += step)output.push(i);
    return output;
}

/**
 * Class representing an N-dimensional vector.
 */ class VectorN {
    /**
   * Create a vector.
   * @param {Array<number>|string} vector - The vector wrote in array or string.
   * @returns {VectorN} The vector.
   */ static create(vector) {
        if (Array.isArray(vector)) return new this(...vector);
        if (typeof vector === "string") return this.parse(vector);
    }
    /**
   * Parse a string to vector.
   * @param {string} vectorStr - The string to parse.
   * @returns {VectorN} The vector.
   */ static parse(vectorStr) {
        return this.create(vectorStr.split(" ").map(Number));
    }
    /**
   * Convert the vector to a string.
   * @returns {string} The string representation of the vector.
   */ stringify() {
        // @ts-ignore
        return this[Symbol.toPrimitive]("string");
    }
    /**
   * Convert the vector to an array.
   * @returns {Array<number>} The array representation of the vector.
   */ toArray() {
        return [
            ...this
        ];
    }
    /**
   * Convert the vector to a primitive value.
   * @param {string} hint - The type hint.
   * @returns {string|VectorN} The string representation or the vector itself.
   */ [Symbol.toPrimitive](hint) {
        if (hint === "string") return this.axes.join(" ");
        return this;
    }
    /**
   * Iterator for the vector axes.
   * @returns {Iterator<number>} The iterator for the axes.
   */ [Symbol.iterator]() {
        return this.axes[Symbol.iterator]();
    }
    /**
   * Get the number of dimensions of the vector.
   * @returns {number} The number of dimensions.
   */ get dimensions() {
        return this.axes.length;
    }
    /**
   * Get an axis of the vector by index.
   * @param {number} index - The index of the component.
   * @returns {number} The component value.
   */ get(index) {
        return this.axes[index];
    }
    /**
   * Set an axis of the vector by index.
   * @param {number} index - The index of the component.
   * @param {number} value - The value to set.
   */ set(index, value) {
        this.axes[index] = value;
    }
    /**
   * Apply a function to each axes of the vector and return a new vector.
   * @param {function(number, number): number} callbackfn - The function to apply.
   * @returns {VectorN} The new vector.
   */ map(callbackfn) {
        return VectorN.create(this.axes.map(callbackfn));
    }
    /**
   * Create a vector.
   * @param {...number} axes - The axes of the vector.
   */ constructor(...axes){
        this.axes = axes;
    }
}

/**
 * Utility class for operations on N-dimensional vectors.
 */ class VectorNUtils {
    /**
   * Create a vector.
   * @param {Array<number>} vector - The vector write in array.
   * @returns {VectorN} The vector.
   */ static create(vector) {
        return VectorN.create(vector);
    }
    /**
   * Clone a vector.
   * @param {VectorN} a - The vector to clone.
   * @returns {VectorN} The cloned vector.
   */ static clone(a) {
        return this.create(a.toArray());
    }
    /**
   * Assert that two vectors have the same dimensions.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @throws Will throw an error if the vectors do not have the same dimensions.
   */ static _assertDimensions(a, b) {
        if (a.dimensions !== b.dimensions) throw new Error("Vectors must have the same dimensions.");
    }
    /**
   * Add two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {VectorN} The resulting vector.
   */ static add(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val + b.get(index));
    }
    /**
   * Subtract one vector from another.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {VectorN} The resulting vector.
   */ static subtract(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val - b.get(index));
    }
    /**
   * Multiply two vectors component-wise.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {VectorN} The resulting vector.
   */ static multiply(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val * b.get(index));
    }
    /**
   * Divide one vector by another component-wise.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {VectorN} The resulting vector.
   */ static divide(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val / b.get(index));
    }
    /**
   * Scale a vector by a scalar.
   * @param {VectorN} a - The vector to scale.
   * @param {number} n - The scalar value.
   * @returns {VectorN} The resulting vector.
   */ static scale(a, n) {
        return a.map((val)=>val * n);
    }
    /**
   * Negate a vector.
   * @param {VectorN} a - The vector to negate.
   * @returns {VectorN} The resulting vector.
   */ static negate(a) {
        return a.map((val)=>-val);
    }
    /**
   * Invert a vector component-wise.
   * @param {VectorN} a - The vector to invert.
   * @returns {VectorN} The resulting vector.
   */ static inverse(a) {
        return a.map((val)=>1 / val);
    }
    /**
   * Exchange two axes of a vector.
   * @param {VectorN} a - The vector to modify.
   * @param {number} axis1 - The first axis to exchange.
   * @param {number} axis2 - The second axis to exchange
   * @returns {VectorN} The resulting vector.
   * @throws Will throw an error if the length of the axes array is not 2.
   */ static exchange(a, axis1, axis2) {
        const output = this.clone(a);
        const n0 = output.get(axis1);
        const n1 = output.get(axis2);
        output.set(axis1, n1);
        output.set(axis2, n0);
        return output;
    }
    /**
   * Check if two vectors are exactly equal.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {boolean} True if the vectors are exactly equal, otherwise false.
   */ static exactEquals(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.axes.every((val, index)=>val === b.get(index));
    }
    /**
   * Check if two vectors are approximately equal.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {boolean} True if the vectors are approximately equal, otherwise false.
   */ static equals(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.axes.every((val, index)=>equals(val, b.get(index)));
    }
    /**
   * Get the component-wise maximum of multiple vectors.
   * @param {...VectorN} vectors - The vectors to compare.
   * @returns {VectorN} The resulting vector.
   */ static max(...vectors) {
        const length = vectors[0].dimensions;
        const maxAxes = vectors.reduce((acc, vector)=>{
            vector.axes.forEach((val, index)=>{
                if (val > acc[index]) acc[index] = val;
            });
            return acc;
        }, new Array(length).fill(Number.NEGATIVE_INFINITY));
        return this.create(maxAxes);
    }
    /**
   * Get the component-wise minimum of multiple vectors.
   * @param {...VectorN} vectors - The vectors to compare.
   * @returns {VectorN} The resulting vector.
   */ static min(...vectors) {
        const length = vectors[0].dimensions;
        const minAxes = vectors.reduce((acc, vector)=>{
            vector.axes.forEach((val, index)=>{
                if (val < acc[index]) acc[index] = val;
            });
            return acc;
        }, new Array(length).fill(Number.POSITIVE_INFINITY));
        return this.create(minAxes);
    }
    /**
   * Apply the floor function to each component of a vector.
   * @param {VectorN} a - The vector to modify.
   * @returns {VectorN} The resulting vector.
   */ static floor(a) {
        return a.map((val)=>Math.floor(val));
    }
    /**
   * Apply the ceil function to each component of a vector.
   * @param {VectorN} a - The vector to modify.
   * @returns {VectorN} The resulting vector.
   */ static ceil(a) {
        return a.map((val)=>Math.ceil(val));
    }
    /**
   * Apply the round function to each component of a vector.
   * @param {VectorN} a - The vector to modify.
   * @returns {VectorN} The resulting vector.
   */ static round(a) {
        return a.map((val)=>round(val));
    }
    /**
   * Apply the absolute value function to each component of a vector.
   * @param {VectorN} a - The vector to modify.
   * @returns {VectorN} The resulting vector.
   */ static abs(a) {
        return a.map((val)=>Math.abs(val));
    }
    /**
   * Get the vector with the maximum magnitude from a list of vectors.
   * @param {...VectorN} vectors - The vectors to compare.
   * @returns {VectorN} The vector with the maximum magnitude.
   */ static maxMagnitude(...vectors) {
        return vectors.reduce((prev, curr)=>VectorNUtils.magnitude(curr) > VectorNUtils.magnitude(prev) ? curr : prev);
    }
    /**
   * Get the vector with the minimum magnitude from a list of vectors.
   * @param {...VectorN} vectors - The vectors to compare.
   * @returns {VectorN} The vector with the minimum magnitude.
   */ static minMagnitude(...vectors) {
        return vectors.reduce((prev, curr)=>VectorNUtils.magnitude(curr) < VectorNUtils.magnitude(prev) ? curr : prev);
    }
    /**
   * Calculate the magnitude of a vector.
   * @param {VectorN} a - The vector to calculate the magnitude of.
   * @returns {number} The magnitude of the vector.
   */ static magnitude(a) {
        return Math.sqrt(VectorNUtils.squaredMagnitude(a));
    }
    /**
   * Calculate the squared magnitude of a vector.
   * @param {VectorN} a - The vector to calculate the squared magnitude of.
   * @returns {number} The squared magnitude of the vector.
   */ static squaredMagnitude(a) {
        return a.axes.reduce((sum, val)=>sum + val ** 2, 0);
    }
    /**
   * Calculate the distance between two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {number} The distance between the vectors.
   */ static distance(a, b) {
        return Math.sqrt(VectorNUtils.squaredDistance(a, b));
    }
    /**
   * Calculate the squared distance between two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {number} The squared distance between the vectors.
   */ static squaredDistance(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.axes.reduce((sum, val, index)=>{
            const diff = val - b.get(index);
            return sum + diff ** 2;
        }, 0);
    }
    /**
   * Calculate the dot product of two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {number} The dot product of the vectors.
   */ static dot(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.axes.reduce((sum, val, index)=>sum + val * b.get(index), 0);
    }
    /**
   * Normalize a vector.
   * @param {VectorN} a - The vector to normalize.
   * @returns {VectorN} The normalized vector.
   */ static normalize(a) {
        const magnitude = this.magnitude(a);
        if (magnitude) return this.scale(a, 1 / magnitude);
        return this.create(new Array(a.dimensions).fill(0));
    }
    /**
   * Calculate the angle between two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @returns {number} The angle between the vectors in radians.
   */ static angle(a, b) {
        const cosOmega = this.dot(this.normalize(a), this.normalize(b));
        return Math.acos(cosOmega);
    }
    /**
   * Generate a random vector.
   * @param {number} dimensions - The number of dimensions.
   * @param {number} [scale=1] - The scale of the random components.
   * @returns {VectorN} The random vector.
   */ static random(dimensions, scale = 1) {
        const axes = Array.from({
            length: dimensions
        }, ()=>Math.random() * 2 - 1);
        return this.scale(this.create(axes), scale);
    }
    /**
   * Perform linear interpolation between two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @param {number} t - The interpolation parameter.
   * @returns {VectorN} The interpolated vector.
   */ static lerp(a, b, t) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val * (1 - t) + b.get(index) * t);
    }
    /**
   * Perform spherical linear interpolation between two vectors.
   * @param {VectorN} a - The first vector.
   * @param {VectorN} b - The second vector.
   * @param {number} t - The interpolation parameter.
   * @returns {VectorN} The interpolated vector.
   */ static slerp(a, b, t) {
        if (t <= 0) return this.clone(a);
        if (t >= 1) return this.clone(b);
        const omega = this.angle(a, b);
        const sinOmega = Math.sin(omega);
        if (sinOmega <= Number.EPSILON) return this.lerp(a, b, t);
        const ratioA = Math.sin(omega * (1 - t)) / sinOmega;
        const ratioB = Math.sin(omega * t) / sinOmega;
        return a.map((val, index)=>val * ratioA + b.get(index) * ratioB);
    }
    /**
   * Perform Bezier interpolation between vectors.
   * @param {VectorN[]} points - The control points.
   * @param {number} t - The interpolation parameter.
   * @returns {VectorN} The interpolated vector.
   */ static bezier(points, t) {
        const n = points.length - 1;
        if (!n) return points[0];
        const newPoints = [];
        for(let i = 0; i < n; i++){
            newPoints.push(this.lerp(points[i], points[i + 1], t));
        }
        return this.bezier(newPoints, t);
    }
}

/**
 * Utility class for operations on 3D vectors.
 */ class Vector3Utils extends VectorNUtils {
    /**
   * @param {Array<number>|string|{x:number,y:number,z:number}} vector - The vector write in array.
   * @returns {Vector3} The vector.
   */ static create(vector) {
        return Vector3.create(vector);
    }
    /**
   * Calculate the cross product of two 3D vectors.
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @returns {Vector3} The cross product of the vectors.
   */ static cross(a, b) {
        return this.create([
            a.y * b.z - a.z * b.y,
            a.z * b.x - a.x * b.z,
            a.x * b.y - a.y * b.x
        ]);
    }
}

/**
 * Class representing a 3-dimensional vector.
 * @extends VectorN
 */ class Vector3 extends VectorN {
    get x() {
        return this.get(0);
    }
    set x(value) {
        this.set(0, value);
    }
    get y() {
        return this.get(1);
    }
    set y(value) {
        this.set(1, value);
    }
    get z() {
        return this.get(2);
    }
    set z(value) {
        this.set(2, value);
    }
    /**
   * @param {Array<number>|string|{x:number,y:number,z:number}} vector - The vector write in array.
   * @returns {Vector3} The vector.
   */ static create(vector) {
        if (Array.isArray(vector)) return new this(...vector);
        // @ts-ignore
        if (typeof vector === "string") return this.parse(vector);
        if (typeof vector === "object") return new this(vector.x, vector.y, vector.z);
    }
    get magnitude() {
        return Vector3Utils.magnitude(this);
    }
    get squaredMagnitude() {
        return Vector3Utils.squaredMagnitude(this);
    }
    get normalized() {
        return Vector3Utils.normalize(this);
    }
    get floored() {
        return Vector3Utils.floor(this);
    }
    get ceiled() {
        return Vector3Utils.ceil(this);
    }
    get rounded() {
        return Vector3Utils.round(this);
    }
    get absoluted() {
        return Vector3Utils.abs(this);
    }
    /**
   * Apply a function to each axes of the vector and return a new vector.
   * @param {function(number, number): number} callbackfn - The function to apply.
   * @returns {Vector3} The new vector.
   */ map(callbackfn) {
        return Vector3.create(this.axes.map(callbackfn));
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    clone() {
        return new Vector3(this.x, this.y, this.z);
    }
    equals(v) {
        return Vector3Utils.equals(this, v);
    }
    distanceTo(v) {
        return Vector3Utils.distance(this, v);
    }
    squaredDistanceTo(v) {
        return Vector3Utils.squaredDistance(this, v);
    }
    add(v) {
        return this.copy(Vector3Utils.add(this, v));
    }
    subtract(v) {
        return this.copy(Vector3Utils.subtract(this, v));
    }
    multiply(v) {
        return this.copy(Vector3Utils.multiply(this, v));
    }
    divide(v) {
        return this.copy(Vector3Utils.divide(this, v));
    }
    scale(n) {
        return this.copy(Vector3Utils.scale(this, n));
    }
    negate() {
        return this.copy(Vector3Utils.negate(this));
    }
    inverse() {
        return this.copy(Vector3Utils.inverse(this));
    }
    floor() {
        return this.copy(this.floored);
    }
    ceil() {
        return this.copy(this.ceiled);
    }
    round() {
        return this.copy(this.rounded);
    }
    abs() {
        return this.copy(this.absoluted);
    }
    normalize() {
        return this.copy(this.normalized);
    }
    /**
   * Create a 3D vector.
   * @param {number} x - The x axis.
   * @param {number} y - The y axis.
   * @param {number} z - The z axis.
   */ constructor(x = 0, y = 0, z = 0){
        super(x, y, z);
    }
}

class Location extends Vector3 {
    get centerCorrected() {
        return Location.create(// @ts-ignore
        Vector3Utils.add(this.floored, new Vector3(0.5, 0.5, 0.5)));
    }
    clone() {
        return new Location(this.x, this.y, this.z);
    }
    equals(v) {
        return Vector3Utils.exactEquals(this, v);
    }
    isNearTo(v, distance) {
        return this.distanceTo(v) <= distance;
    }
    offset(v) {
        return this.add(v);
    }
}

function asyncRun(fn) {
    return new Promise((resolve, reject)=>{
        system.run(()=>{
            try {
                resolve(fn());
            } catch (err) {
                reject(err);
            }
        });
    });
}
function errorHandler(errText, target) {
    const err = new Error(errText);
    target.sendMessage(err.toString());
    return err;
}
function waitForFirstPlayerInitialSpawn() {
    const players = world.getAllPlayers();
    if (players.length) return Promise.resolve(players[0]);
    return new Promise((resolve)=>{
        const callback = world.afterEvents.playerSpawn.subscribe((event)=>{
            if (event.initialSpawn) resolve(event.player);
            world.afterEvents.playerSpawn.unsubscribe(callback);
        });
    });
}
function getOrAddObjective(id, name) {
    const objective = world.scoreboard.getObjective(id);
    if (!objective && !name) throw new Error(`Couldn't find objective "${id}".`);
    if (!objective) return world.scoreboard.addObjective(id, name);
    return objective;
}
function removeMinecraftNamespace(identifier) {
    return identifier.replace(/^minecraft\:/, "");
}

class Direction {
    get name() {
        switch(this.code){
            case 0:
                return "East";
            case 1:
                return "South";
            case 2:
                return "Up";
            case 3:
                return "West";
            case 4:
                return "North";
            case 5:
                return "Down";
        }
    }
    isEast() {
        return this.code === 0;
    }
    isSouth() {
        return this.code === 1;
    }
    isUp() {
        return this.code === 2;
    }
    isWest() {
        return this.code === 3;
    }
    isNorth() {
        return this.code === 4;
    }
    isDown() {
        return this.code === 5;
    }
    equals(direction) {
        return this.code === direction.code;
    }
    getOpposite() {
        const directionCode = this.code + 3;
        return new Direction(directionCode >= 6 ? directionCode - 6 : directionCode);
    }
    isOppositeTo(direction) {
        return Math.abs(this.code - direction.code) === 3;
    }
    constructor(directionCode){
        this.code = directionCode;
    }
}
class Directions {
}
Directions.East = new Direction(0) // x+
;
Directions.South = new Direction(1) // z+
;
Directions.Up = new Direction(2) // y+
;
Directions.West = new Direction(3) // x-
;
Directions.North = new Direction(4) // z-
;
Directions.Down = new Direction(5) // y-
;

class WrapperTemplate {
    static wrap(...args) {
        // return the class extending this
        // @ts-ignore
        return new this(...args);
    }
    static tryWrap(...args) {
        try {
            // return the class extending this
            // @ts-ignore
            return new this(...args);
        } catch (err) {}
    }
    static match() {
        throw new Error("Not implemented.");
    }
    static assert() {
        throw new Error("Not implemented.");
    }
}

class WrappedEntity extends WrapperTemplate {
    get nameTag() {
        return this._entity.nameTag;
    }
    get location() {
        return Location.create(this._entity.location);
    }
    get dimension() {
        return this._entity.dimension;
    }
    get isSneaking() {
        return this._entity.isSneaking;
    }
    getRotation() {
        return this._entity.getRotation();
    }
    getFacingDirectionXZ() {
        const rotation = this.getRotation().y;
        if (rotation > -135 && rotation <= -45) return Directions.East;
        if (rotation > -45 && rotation <= 45) return Directions.South;
        if (rotation > 45 && rotation <= 135) return Directions.West;
        if (rotation > 135 || rotation <= -135) return Directions.North;
    }
    constructor(entity){
        super();
        this.components = new Map();
        this._entity = entity;
        this.id = entity.id;
        this.typeId = entity.typeId;
        this.scoreboardIdentity = entity.scoreboardIdentity;
        const components = entity.getComponents();
        each(components, (component)=>{
            this.components.set(removeMinecraftNamespace(component.typeId), component);
        });
    }
}

class Container extends WrapperTemplate {
    get size() {
        return this._container.size;
    }
    get emptySlotsCount() {
        return this._container.emptySlotsCount;
    }
    getItem(slot) {
        return this._container.getItem(slot);
    }
    setItem(slot, itemStack) {
        return this._container.setItem(slot, itemStack);
    }
    tryAddItem(itemStack) {
        return this._container.addItem(itemStack);
    }
    constructor(container){
        super();
        this._container = container;
    }
}

class EntityContainer extends Container {
    get location() {
        return this._entity.location;
    }
    get dimension() {
        return this._entity.dimension;
    }
    addItem(itemStack) {
        const remain = this.tryAddItem(itemStack);
        if (remain) this.dimension.spawnItem(remain, this.location);
    }
    constructor(entity, container){
        super(container);
        this._entity = entity;
    }
}

class WrappedPlayer extends WrappedEntity {
    static match(entity) {
        return entity.typeId === "minecraft:player";
    }
    get _player() {
        return this._entity;
    }
    get experience() {
        return this.addExperience(0);
    }
    get level() {
        return this._player.level;
    }
    get inventory() {
        return new EntityContainer(this, this.components.get("inventory").container);
    }
    get selectedSlotIndex() {
        return this._player.selectedSlotIndex;
    }
    getGameMode() {
        const matches = [];
        each(GameMode, (mode)=>{
            if (this.testGameMode(mode)) matches.push(mode);
        });
        return matches[0];
    }
    testGameMode(mode) {
        const playersUnderMode = this.dimension.getPlayers({
            gameMode: mode
        });
        return playersUnderMode.some((player)=>player.id === this.id);
    }
    setGameMode(mode) {
        if (!Object.values(GameMode).includes(mode)) throw new TypeError("Unknown gamemode.");
        Commands.run(`gamemode ${mode}`, this._player);
    }
    getMainHandItem() {
        return this.inventory.getItem(this.selectedSlotIndex);
    }
    setMainHandItem(item) {
        this.inventory.setItem(this.selectedSlotIndex, item);
    }
    async useItemFromInventory(slot, callback = async (_)=>{}) {
        let itemStack = this.inventory.getItem(slot);
        itemStack = await callback(itemStack);
        this.inventory.setItem(slot, itemStack);
    }
    async useMainHandItem(callback = async ()=>{}) {
        await this.useItemFromInventory(this.selectedSlotIndex, callback);
    }
    addExperience(amount = 0, { useXpOrb = false } = {}) {
        if (useXpOrb && amount >= 0) {
            while(amount--)this.dimension.spawnEntity("minecraft:xp_orb", this.location);
            return this.experience;
        }
        return this._player.addExperience(amount);
    }
    addLevels(amount = 0) {
        return this._player.addLevels(amount);
    }
    constructor(player){
        super(player);
        this.name = player.name;
    }
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var md5$1 = {exports: {}};

var crypt = {exports: {}};

(function() {
    var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', crypt$1 = {
        // Bit-wise rotation left
        rotl: function(n, b) {
            return n << b | n >>> 32 - b;
        },
        // Bit-wise rotation right
        rotr: function(n, b) {
            return n << 32 - b | n >>> b;
        },
        // Swap big-endian to little-endian and vice versa
        endian: function(n) {
            // If number given, swap endian
            if (n.constructor == Number) {
                return crypt$1.rotl(n, 8) & 0x00FF00FF | crypt$1.rotl(n, 24) & 0xFF00FF00;
            }
            // Else, assume array and swap all items
            for(var i = 0; i < n.length; i++)n[i] = crypt$1.endian(n[i]);
            return n;
        },
        // Generate an array of any length of random bytes
        randomBytes: function(n) {
            for(var bytes = []; n > 0; n--)bytes.push(Math.floor(Math.random() * 256));
            return bytes;
        },
        // Convert a byte array to big-endian 32-bit words
        bytesToWords: function(bytes) {
            for(var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)words[b >>> 5] |= bytes[i] << 24 - b % 32;
            return words;
        },
        // Convert big-endian 32-bit words to a byte array
        wordsToBytes: function(words) {
            for(var bytes = [], b = 0; b < words.length * 32; b += 8)bytes.push(words[b >>> 5] >>> 24 - b % 32 & 0xFF);
            return bytes;
        },
        // Convert a byte array to a hex string
        bytesToHex: function(bytes) {
            for(var hex = [], i = 0; i < bytes.length; i++){
                hex.push((bytes[i] >>> 4).toString(16));
                hex.push((bytes[i] & 0xF).toString(16));
            }
            return hex.join('');
        },
        // Convert a hex string to a byte array
        hexToBytes: function(hex) {
            for(var bytes = [], c = 0; c < hex.length; c += 2)bytes.push(parseInt(hex.substr(c, 2), 16));
            return bytes;
        },
        // Convert a byte array to a base-64 string
        bytesToBase64: function(bytes) {
            for(var base64 = [], i = 0; i < bytes.length; i += 3){
                var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
                for(var j = 0; j < 4; j++)if (i * 8 + j * 6 <= bytes.length * 8) base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 0x3F));
                else base64.push('=');
            }
            return base64.join('');
        },
        // Convert a base-64 string to a byte array
        base64ToBytes: function(base64) {
            // Remove non-base-64 characters
            base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');
            for(var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4){
                if (imod4 == 0) continue;
                bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
            }
            return bytes;
        }
    };
    crypt.exports = crypt$1;
})();

var cryptExports = crypt.exports;

var charenc = {
    // UTF-8 encoding
    utf8: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
            return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
            return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
        }
    },
    // Binary encoding
    bin: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
            for(var bytes = [], i = 0; i < str.length; i++)bytes.push(str.charCodeAt(i) & 0xFF);
            return bytes;
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
            for(var str = [], i = 0; i < bytes.length; i++)str.push(String.fromCharCode(bytes[i]));
            return str.join('');
        }
    }
};
var charenc_1 = charenc;

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
var isBuffer_1 = function(obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}
// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

(function() {
    var crypt = cryptExports, utf8 = charenc_1.utf8, isBuffer = isBuffer_1, bin = charenc_1.bin, // The core
    md5 = function(message, options) {
        // Convert to byte array
        if (message.constructor == String) if (options && options.encoding === 'binary') message = bin.stringToBytes(message);
        else message = utf8.stringToBytes(message);
        else if (isBuffer(message)) message = Array.prototype.slice.call(message, 0);
        else if (!Array.isArray(message) && message.constructor !== Uint8Array) message = message.toString();
        // else, assume byte array already
        var m = crypt.bytesToWords(message), l = message.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
        // Swap endian
        for(var i = 0; i < m.length; i++){
            m[i] = (m[i] << 8 | m[i] >>> 24) & 0x00FF00FF | (m[i] << 24 | m[i] >>> 8) & 0xFF00FF00;
        }
        // Padding
        m[l >>> 5] |= 0x80 << l % 32;
        m[(l + 64 >>> 9 << 4) + 14] = l;
        // Method shortcuts
        var FF = md5._ff, GG = md5._gg, HH = md5._hh, II = md5._ii;
        for(var i = 0; i < m.length; i += 16){
            var aa = a, bb = b, cc = c, dd = d;
            a = FF(a, b, c, d, m[i + 0], 7, -680876936);
            d = FF(d, a, b, c, m[i + 1], 12, -389564586);
            c = FF(c, d, a, b, m[i + 2], 17, 606105819);
            b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
            a = FF(a, b, c, d, m[i + 4], 7, -176418897);
            d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
            c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
            b = FF(b, c, d, a, m[i + 7], 22, -45705983);
            a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
            d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
            c = FF(c, d, a, b, m[i + 10], 17, -42063);
            b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
            a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
            d = FF(d, a, b, c, m[i + 13], 12, -40341101);
            c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
            b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
            a = GG(a, b, c, d, m[i + 1], 5, -165796510);
            d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
            c = GG(c, d, a, b, m[i + 11], 14, 643717713);
            b = GG(b, c, d, a, m[i + 0], 20, -373897302);
            a = GG(a, b, c, d, m[i + 5], 5, -701558691);
            d = GG(d, a, b, c, m[i + 10], 9, 38016083);
            c = GG(c, d, a, b, m[i + 15], 14, -660478335);
            b = GG(b, c, d, a, m[i + 4], 20, -405537848);
            a = GG(a, b, c, d, m[i + 9], 5, 568446438);
            d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
            c = GG(c, d, a, b, m[i + 3], 14, -187363961);
            b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
            a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
            d = GG(d, a, b, c, m[i + 2], 9, -51403784);
            c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
            b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
            a = HH(a, b, c, d, m[i + 5], 4, -378558);
            d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
            c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
            b = HH(b, c, d, a, m[i + 14], 23, -35309556);
            a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
            d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
            c = HH(c, d, a, b, m[i + 7], 16, -155497632);
            b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
            a = HH(a, b, c, d, m[i + 13], 4, 681279174);
            d = HH(d, a, b, c, m[i + 0], 11, -358537222);
            c = HH(c, d, a, b, m[i + 3], 16, -722521979);
            b = HH(b, c, d, a, m[i + 6], 23, 76029189);
            a = HH(a, b, c, d, m[i + 9], 4, -640364487);
            d = HH(d, a, b, c, m[i + 12], 11, -421815835);
            c = HH(c, d, a, b, m[i + 15], 16, 530742520);
            b = HH(b, c, d, a, m[i + 2], 23, -995338651);
            a = II(a, b, c, d, m[i + 0], 6, -198630844);
            d = II(d, a, b, c, m[i + 7], 10, 1126891415);
            c = II(c, d, a, b, m[i + 14], 15, -1416354905);
            b = II(b, c, d, a, m[i + 5], 21, -57434055);
            a = II(a, b, c, d, m[i + 12], 6, 1700485571);
            d = II(d, a, b, c, m[i + 3], 10, -1894986606);
            c = II(c, d, a, b, m[i + 10], 15, -1051523);
            b = II(b, c, d, a, m[i + 1], 21, -2054922799);
            a = II(a, b, c, d, m[i + 8], 6, 1873313359);
            d = II(d, a, b, c, m[i + 15], 10, -30611744);
            c = II(c, d, a, b, m[i + 6], 15, -1560198380);
            b = II(b, c, d, a, m[i + 13], 21, 1309151649);
            a = II(a, b, c, d, m[i + 4], 6, -145523070);
            d = II(d, a, b, c, m[i + 11], 10, -1120210379);
            c = II(c, d, a, b, m[i + 2], 15, 718787259);
            b = II(b, c, d, a, m[i + 9], 21, -343485551);
            a = a + aa >>> 0;
            b = b + bb >>> 0;
            c = c + cc >>> 0;
            d = d + dd >>> 0;
        }
        return crypt.endian([
            a,
            b,
            c,
            d
        ]);
    };
    // Auxiliary functions
    md5._ff = function(a, b, c, d, x, s, t) {
        var n = a + (b & c | ~b & d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
    };
    md5._gg = function(a, b, c, d, x, s, t) {
        var n = a + (b & d | c & ~d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
    };
    md5._hh = function(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
    };
    md5._ii = function(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
    };
    // Package private blocksize
    md5._blocksize = 16;
    md5._digestsize = 16;
    md5$1.exports = function(message, options) {
        if (message === undefined || message === null) throw new Error('Illegal argument ' + message);
        var digestbytes = crypt.wordsToBytes(md5(message, options));
        return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
    };
})();

var md5Exports = md5$1.exports;
var md5 = /*@__PURE__*/getDefaultExportFromCjs(md5Exports);

var randombytes = require$$0.randomBytes;

/*
Copyright (c) 2014, Yahoo! Inc. All rights reserved.
Copyrights licensed under the New BSD License.
See the accompanying LICENSE file for terms.
*/
var randomBytes = randombytes;
// Generate an internal UID to make the regexp pattern harder to guess.
var UID_LENGTH = 16;
var UID = generateUID();
var PLACE_HOLDER_REGEXP = new RegExp('(\\\\)?"@__(F|R|D|M|S|A|U|I|B|L)-' + UID + '-(\\d+)__@"', 'g');
var IS_NATIVE_CODE_REGEXP = /\{\s*\[native code\]\s*\}/g;
var IS_PURE_FUNCTION = /function.*?\(/;
var IS_ARROW_FUNCTION = /.*?=>.*?/;
var UNSAFE_CHARS_REGEXP = /[<>\/\u2028\u2029]/g;
var RESERVED_SYMBOLS = [
    '*',
    'async'
];
// Mapping of unsafe HTML and invalid JavaScript line terminator chars to their
// Unicode char counterparts which are safe to use in JavaScript strings.
var ESCAPED_CHARS = {
    '<': '\\u003C',
    '>': '\\u003E',
    '/': '\\u002F',
    '\u2028': '\\u2028',
    '\u2029': '\\u2029'
};
function escapeUnsafeChars(unsafeChar) {
    return ESCAPED_CHARS[unsafeChar];
}
function generateUID() {
    var bytes = randomBytes(UID_LENGTH);
    var result = '';
    for(var i = 0; i < UID_LENGTH; ++i){
        result += bytes[i].toString(16);
    }
    return result;
}
function deleteFunctions(obj) {
    var functionKeys = [];
    for(var key in obj){
        if (typeof obj[key] === "function") {
            functionKeys.push(key);
        }
    }
    for(var i = 0; i < functionKeys.length; i++){
        delete obj[functionKeys[i]];
    }
}
var serializeJavascript = function serialize(obj, options) {
    options || (options = {});
    // Backwards-compatibility for `space` as the second argument.
    if (typeof options === 'number' || typeof options === 'string') {
        options = {
            space: options
        };
    }
    var functions = [];
    var regexps = [];
    var dates = [];
    var maps = [];
    var sets = [];
    var arrays = [];
    var undefs = [];
    var infinities = [];
    var bigInts = [];
    var urls = [];
    // Returns placeholders for functions and regexps (identified by index)
    // which are later replaced by their string representation.
    function replacer(key, value) {
        // For nested function
        if (options.ignoreFunction) {
            deleteFunctions(value);
        }
        if (!value && value !== undefined && value !== BigInt(0)) {
            return value;
        }
        // If the value is an object w/ a toJSON method, toJSON is called before
        // the replacer runs, so we use this[key] to get the non-toJSONed value.
        var origValue = this[key];
        var type = typeof origValue;
        if (type === 'object') {
            if (origValue instanceof RegExp) {
                return '@__R-' + UID + '-' + (regexps.push(origValue) - 1) + '__@';
            }
            if (origValue instanceof Date) {
                return '@__D-' + UID + '-' + (dates.push(origValue) - 1) + '__@';
            }
            if (origValue instanceof Map) {
                return '@__M-' + UID + '-' + (maps.push(origValue) - 1) + '__@';
            }
            if (origValue instanceof Set) {
                return '@__S-' + UID + '-' + (sets.push(origValue) - 1) + '__@';
            }
            if (origValue instanceof Array) {
                var isSparse = origValue.filter(function() {
                    return true;
                }).length !== origValue.length;
                if (isSparse) {
                    return '@__A-' + UID + '-' + (arrays.push(origValue) - 1) + '__@';
                }
            }
            if (origValue instanceof URL) {
                return '@__L-' + UID + '-' + (urls.push(origValue) - 1) + '__@';
            }
        }
        if (type === 'function') {
            return '@__F-' + UID + '-' + (functions.push(origValue) - 1) + '__@';
        }
        if (type === 'undefined') {
            return '@__U-' + UID + '-' + (undefs.push(origValue) - 1) + '__@';
        }
        if (type === 'number' && !isNaN(origValue) && !isFinite(origValue)) {
            return '@__I-' + UID + '-' + (infinities.push(origValue) - 1) + '__@';
        }
        if (type === 'bigint') {
            return '@__B-' + UID + '-' + (bigInts.push(origValue) - 1) + '__@';
        }
        return value;
    }
    function serializeFunc(fn) {
        var serializedFn = fn.toString();
        if (IS_NATIVE_CODE_REGEXP.test(serializedFn)) {
            throw new TypeError('Serializing native function: ' + fn.name);
        }
        // pure functions, example: {key: function() {}}
        if (IS_PURE_FUNCTION.test(serializedFn)) {
            return serializedFn;
        }
        // arrow functions, example: arg1 => arg1+5
        if (IS_ARROW_FUNCTION.test(serializedFn)) {
            return serializedFn;
        }
        var argsStartsAt = serializedFn.indexOf('(');
        var def = serializedFn.substr(0, argsStartsAt).trim().split(' ').filter(function(val) {
            return val.length > 0;
        });
        var nonReservedSymbols = def.filter(function(val) {
            return RESERVED_SYMBOLS.indexOf(val) === -1;
        });
        // enhanced literal objects, example: {key() {}}
        if (nonReservedSymbols.length > 0) {
            return (def.indexOf('async') > -1 ? 'async ' : '') + 'function' + (def.join('').indexOf('*') > -1 ? '*' : '') + serializedFn.substr(argsStartsAt);
        }
        // arrow functions
        return serializedFn;
    }
    // Check if the parameter is function
    if (options.ignoreFunction && typeof obj === "function") {
        obj = undefined;
    }
    // Protects against `JSON.stringify()` returning `undefined`, by serializing
    // to the literal string: "undefined".
    if (obj === undefined) {
        return String(obj);
    }
    var str;
    // Creates a JSON string representation of the value.
    // NOTE: Node 0.12 goes into slow mode with extra JSON.stringify() args.
    if (options.isJSON && !options.space) {
        str = JSON.stringify(obj);
    } else {
        str = JSON.stringify(obj, options.isJSON ? null : replacer, options.space);
    }
    // Protects against `JSON.stringify()` returning `undefined`, by serializing
    // to the literal string: "undefined".
    if (typeof str !== 'string') {
        return String(str);
    }
    // Replace unsafe HTML and invalid JavaScript line terminator chars with
    // their safe Unicode char counterpart. This _must_ happen before the
    // regexps and functions are serialized and added back to the string.
    if (options.unsafe !== true) {
        str = str.replace(UNSAFE_CHARS_REGEXP, escapeUnsafeChars);
    }
    if (functions.length === 0 && regexps.length === 0 && dates.length === 0 && maps.length === 0 && sets.length === 0 && arrays.length === 0 && undefs.length === 0 && infinities.length === 0 && bigInts.length === 0 && urls.length === 0) {
        return str;
    }
    // Replaces all occurrences of function, regexp, date, map and set placeholders in the
    // JSON string with their string representations. If the original value can
    // not be found, then `undefined` is used.
    return str.replace(PLACE_HOLDER_REGEXP, function(match, backSlash, type, valueIndex) {
        // The placeholder may not be preceded by a backslash. This is to prevent
        // replacing things like `"a\"@__R-<UID>-0__@"` and thus outputting
        // invalid JS.
        if (backSlash) {
            return match;
        }
        if (type === 'D') {
            return "new Date(\"" + dates[valueIndex].toISOString() + "\")";
        }
        if (type === 'R') {
            return "new RegExp(" + serialize(regexps[valueIndex].source) + ", \"" + regexps[valueIndex].flags + "\")";
        }
        if (type === 'M') {
            return "new Map(" + serialize(Array.from(maps[valueIndex].entries()), options) + ")";
        }
        if (type === 'S') {
            return "new Set(" + serialize(Array.from(sets[valueIndex].values()), options) + ")";
        }
        if (type === 'A') {
            return "Array.prototype.slice.call(" + serialize(Object.assign({
                length: arrays[valueIndex].length
            }, arrays[valueIndex]), options) + ")";
        }
        if (type === 'U') {
            return 'undefined';
        }
        if (type === 'I') {
            return infinities[valueIndex];
        }
        if (type === 'B') {
            return "BigInt(\"" + bigInts[valueIndex] + "\")";
        }
        if (type === 'L') {
            return "new URL(" + serialize(urls[valueIndex].toString(), options) + ")";
        }
        var fn = functions[valueIndex];
        return serializeFunc(fn);
    });
};

const ALL_DATABASES = new Map();
class Database {
    static open(player, dbName) {
        return new Database(player, dbName);
    }
    _syncDataFromScoreboard() {
        this.store.clear();
        each(this.objective.getParticipants(), (participant)=>{
            const data = deserialize(participant.displayName);
            const key = Object.keys(data)[0];
            const value = data[key];
            this.store.set(key, {
                value,
                participant
            });
        });
    }
    has(key) {
        return this.store.has(key);
    }
    async delete(key) {
        if (this.has(key)) {
            const { participant } = this.store.get(key);
            await asyncRun(()=>this.objective.removeParticipant(participant));
            this.store.delete(key);
            return true;
        }
        return false;
    }
    async clear() {
        await eachAsync(this.store, async ([, { participant }])=>await asyncRun(()=>this.objective.removeParticipant(participant)));
        this.store.clear();
    }
    get(key) {
        if (this.has(key)) return this.store.get(key).value;
    }
    async set(key, value) {
        await this.delete(key);
        const data = serializeJavascript.serialize({
            [key]: value
        }).replaceAll('"', "'");
        // FIXME: has ambiguity
        if (data.length > 32767) throw new RangeError("Database: Only accepts a string value less than 32767 characters.");
        await asyncRun(()=>this.objective.setScore(data, 1));
        this._syncDataFromScoreboard();
    }
    getAll() {
        const output = {};
        for (const [key, value] of this)output[key] = value;
        return output;
    }
    *entries() {
        for (const [key, { value }] of this.store.entries())yield [
            key,
            value
        ];
    }
    *keys() {
        for (const key of this.store.keys())yield key;
    }
    *values() {
        for (const { value } of this.store.values())yield value;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    constructor(player, dbName){
        this.store = new Map();
        const id = md5(`db:${dbName}_${player.id}`).slice(8, 24);
        this.id = id;
        this.objective = getOrAddObjective(id, `db:${dbName}`);
        // this.player = player
        // if (!(player instanceof Player)) this.fakePlayer = true
        this._syncDataFromScoreboard();
        ALL_DATABASES.set(id, this);
    }
}

const globalDB = new Database({
    id: "global"
}, "scoreboard-statistic-global");
const ALL_PLAYER_DATABASES = new Map();
class EventDB {
    // 此次因为有 events 这个运行时存储项，
    // 而不能多次 construct，
    // 故使用此方法将实例储存到 ALL_PLAYER_DATABASES 中
    static init(player) {
        const db = new EventDB(player);
        ALL_PLAYER_DATABASES.set(player, db);
        return db;
    }
    async addParticipated(objectiveId) {
        const participated = this.getParticipated();
        participated.add(objectiveId);
        await this.db.set("__participated__", participated);
    }
    getParticipated() {
        return new Set(this.db.get("__participated__") ?? []);
    }
    setEvents(objectiveId, events) {
        this.events.set(objectiveId, events);
    }
    getEvents(objectiveId) {
        return this.events.get(objectiveId);
    }
    async add(objectiveId, events) {
        await this.addParticipated(objectiveId);
        this.setEvents(objectiveId, events);
    }
    has(objectiveId) {
        return this.events.has(objectiveId) && this.getParticipated().has(objectiveId);
    }
    async delete(objectiveId) {
        const participated = this.getParticipated();
        if (participated.has(objectiveId)) {
            participated.delete(objectiveId);
            await this.db.set("__participated__", participated);
            this.events.delete(objectiveId);
            return true;
        }
    }
    async clear() {
        await this.db.clear();
        this.events.clear();
    }
    constructor(player){
        this.events = new Map();
        this.db = new Database(player, "scoreboard-statistic-player");
        this.player = player;
    }
}

class Dialog {
    static async confirm({ title = "确认", body, target, onCancel = async ()=>{}, onConfirm = async ()=>{} }) {
        if (!body || !target) throw new Error();
        const form = await asyncRun(()=>{
            return new Dialog({
                dialog: new MessageFormData().title(title).body(body).button1("CANCEL").button2("OK"),
                onClose: onCancel,
                onSelectButton1: onCancel,
                onSelectButton2: onConfirm
            });
        });
        return await form.show(target);
    }
    async show(target) {
        let response;
        target.sendMessage("[!] 新对话框已发送，请关闭命令输入栏或其他对话框");
        do {
            response = await this.dialog.show(target);
        }while (response.cancelationReason === FormCancelationReason.UserBusy)
        if (response.canceled && response.cancelationReason === FormCancelationReason.UserClosed) return await this.onClose();
        if (response instanceof ModalFormResponse) return await this.onSubmit(response.formValues);
        if (response instanceof MessageFormResponse) {
            if (response.selection === 0) return await this.onSelectButton1();
            if (response.selection === 1) return await this.onSelectButton2();
        } else if (response instanceof ActionFormResponse) return await this.onSelect(response.selection);
        return response;
    }
    constructor({ dialog, onClose = async ()=>{}, onSubmit = async (_)=>{}, onSelectButton1 = async ()=>{}, onSelectButton2 = async ()=>{}, onSelect = async (_)=>{} }){
        this.dialog = dialog;
        this.onSubmit = onSubmit;
        this.onSelectButton1 = onSelectButton1;
        this.onSelectButton2 = onSelectButton2;
        this.onSelect = onSelect;
        this.onClose = onClose;
    }
}

class EventEmitter {
    on(eventName, listener) {
        if (isAsyncFunc(listener)) {
            const _eventName = `${eventName}.async`;
            if (this._events[_eventName]) this._events[_eventName].push(listener);
            else this._events[_eventName] = [
                listener
            ];
        } else {
            if (this._events[eventName]) this._events[eventName].push(listener);
            else this._events[eventName] = [
                listener
            ];
        }
        return this;
    }
    once(eventName, listener) {
        if (isAsyncFunc(listener)) {
            const _eventName = `${eventName}.async`;
            const _listener = async (...args)=>{
                await listener(...args);
                this.removeListener(_eventName, _listener);
            };
            if (this._events[_eventName]) this._events[_eventName].push(_listener);
            else this._events[_eventName] = [
                _listener
            ];
        } else {
            const _listener = (...args)=>{
                listener(...args);
                this.removeListener(eventName, _listener);
            };
            if (this._events[eventName]) this._events[eventName].push(_listener);
            else this._events[eventName] = [
                _listener
            ];
        }
        return this;
    }
    removeListener(eventName, listener) {
        if (this._events[eventName]) {
            const newListeners = [];
            each(this._events[eventName], (_listener)=>{
                if (_listener !== listener) newListeners.push(_listener);
            });
            this._events[eventName] = newListeners;
        }
        return this;
    }
    async emit(eventName, ...args) {
        if (this._events[eventName]) {
            each(this._events[eventName], (listener)=>listener(...args));
        }
        await this.asyncEmit(eventName, ...args);
    }
    async asyncEmit(eventName, ...args) {
        const _eventName = `${eventName}.async`;
        if (this._events[_eventName]) {
            await eachAsync(this._events[_eventName], async (listener)=>await listener(...args));
        }
    }
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    off(eventName, listener) {
        return this.removeListener(eventName, listener);
    }
    constructor(){
        this._events = {};
    }
}

class NumberRange {
    toArray() {
        return range(this.min, this.max + this.step, this.step);
    }
    get array() {
        return this.toArray();
    }
    includes(n) {
        return this.array.includes(n);
    }
    [Symbol.iterator]() {
        return this.array.values();
    }
    constructor(min, max, step = 1){
        this.min = min;
        this.max = max;
        this.step = step;
    }
}

class OptionItemRange {
    select(value) {
        if (this.selected !== value && this._includes(value)) {
            this.original = this.selected;
            this.selected = value;
            this.events.emit("selected", this.selected, this.original, this._player);
            this.events.emit("changed", this.selected, this.original, this._player);
            return true;
        }
        return false;
    }
    _includes(n) {
        return this.range.includes(n);
    }
    constructor({ name, description, range = [
        0,
        1,
        1
    ], defaultValue, events, reload, _player }){
        this.name = name;
        this.description = description;
        this.range = new NumberRange(...range);
        this.events = new EventEmitter();
        this.reload = reload;
        this._defaultValue = defaultValue;
        this._player = _player;
        if (events) each(events, (listener, eventName)=>this.events.on(eventName, listener));
        if (defaultValue !== undefined && this._includes(defaultValue)) this.selected = defaultValue;
        else this.selected = this.range.min;
        this.events.emit("inited", this.selected, _player);
        this.events.emit("changed", this.selected, undefined, _player);
    }
}

// @ts-ignore
class OptionItemSelection {
    select(value) {
        if (this.selected !== value && this.hasVal(value)) {
            this.original = this.selected;
            this.selected = value;
            this.events.emit("selected", this.selected, this.original, this._player);
            this.events.emit("changed", this.selected, this.original, this._player);
            return true;
        }
        return false;
    }
    hasVal(name) {
        return this.values.has(name) || !this.values.size;
    }
    constructor({ name, description, values = [], defaultValue, events, reload, _player }){
        this.name = name;
        this.description = description;
        this.values = new Map(values.map((value)=>{
            if (typeof value[0] === "object" || value[0] === undefined) value[0] = serializeJavascript.serialize(value[0]);
            if (value[0] === true && !value[1]) value[1] = "开启";
            else if (value[0] === false && !value[1]) value[1] = "关闭";
            return value;
        }));
        this.events = new EventEmitter();
        this.reload = reload;
        this._defaultValue = defaultValue;
        this._player = _player;
        if (events) each(events, (listener, eventName)=>this.events.on(eventName, listener));
        if (defaultValue !== undefined && this.hasVal(defaultValue)) this.selected = defaultValue;
        else if (values[0]) this.selected = values[0][0];
        this.events.emit("inited", this.selected, _player);
        this.events.emit("changed", this.selected, undefined, _player);
    }
}

class PlayerOption {
    addItem(opts) {
        if (opts.range) this.items[opts.name] = new OptionItemRange(opts);
        else if (opts.values) this.items[opts.name] = new OptionItemSelection(opts);
        return this;
    }
    async _syncToDB() {
        const data = this.getItemValMap();
        await eachAsync(data, async (value, name)=>{
            await this.db.set(name, value);
        });
        await eachAsync(this.db, async ([name, _])=>{
            if (!this.hasItem(name)) await this.db.delete(name);
        });
    }
    async _syncFromDB() {
        each(this.db, ([name, value])=>this.setItemVal(name, value, undefined, {
                syncFromDB: true
            }));
        await this._syncToDB();
    }
    async init() {
        this.addItem = undefined;
        await this._syncFromDB();
        return this.getItemValMap();
    }
    _getItem(name) {
        return this.items[name];
    }
    hasItem(name) {
        return !!this.items[name];
    }
    setItemVal(name, value, callback = (_, __, ___)=>{}, { syncFromDB = false } = {}) {
        const item = this._getItem(name);
        if (item) {
            const result = item.select(value);
            if (result) {
                if (!syncFromDB && item.reload) this.reload = true;
                callback(item.selected, item.original, this.getItemValMap());
            }
        }
        return this;
    }
    getItemVal(name) {
        const item = this._getItem(name);
        if (item) return item.selected;
    }
    getItemValMap() {
        const result = {};
        each(this.items, (_, name)=>{
            result[name] = this.getItemVal(name);
        });
        return result;
    }
    async done(parentDialog) {
        const handleDone = async ({ reply = true } = {})=>{
            await this._syncToDB();
            if (reply) this.player.sendMessage("设置选项修改成功");
        };
        if (this.reload) {
            this.reload = false;
            await Dialog.confirm({
                body: '你选择的项目更改后需要刷新脚本，请手动运行 "/reload" 命令。\n\n您也可以取消您的更改',
                target: this.player,
                onConfirm: async ()=>{
                    await handleDone({
                        reply: false
                    });
                // await Commands.asyncRun("reload")
                },
                onCancel: async ()=>{
                    await this._syncFromDB();
                    await this.showDialog(parentDialog);
                }
            });
        } else await handleDone();
    }
    async showDialog(parentDialog) {
        const form = new ModalFormData().title(`${this.name} 选项`);
        const nameMap = [];
        each(this.items, (item)=>{
            if (item instanceof OptionItemSelection) {
                const { name, description, values, selected } = item;
                if (values.size === 2 && values.get(true) && values.get(false)) {
                    const valuesMap = new Map();
                    each(values, ([e])=>valuesMap.set(e, e));
                    nameMap.push({
                        name,
                        valuesMap
                    });
                    form.toggle(description, selected);
                } else {
                    const valueArray = [
                        ...values
                    ];
                    const valuesMap = new Map();
                    each(valueArray, ([e], i)=>valuesMap.set(i, e));
                    nameMap.push({
                        name,
                        valuesMap
                    });
                    form.dropdown(description, valueArray.map((e)=>e[1]), valueArray.map((e)=>e[0]).findIndex((e)=>e === selected));
                }
            } else if (item instanceof OptionItemRange) {
                const { name, description, range, selected } = item;
                const valuesMap = new Map();
                each(range, (i)=>valuesMap.set(i, i));
                nameMap.push({
                    name,
                    valuesMap
                });
                form.slider(description, range.min, range.max, range.step, selected);
            }
        });
        const dialog = new Dialog({
            dialog: form,
            onClose: async ()=>{
                if (parentDialog) await parentDialog.show(this.player);
            },
            onSubmit: async (result)=>{
                each(result, (valueIndex, nameIndex)=>{
                    const { name, valuesMap } = nameMap[nameIndex];
                    const value = valuesMap.get(valueIndex);
                    this.setItemVal(name, value);
                });
                await this.done(parentDialog);
            }
        });
        await dialog.show(this.player);
    }
    constructor(player, name){
        this.items = {};
        this.name = name;
        this.db = Database.open(player, `option-manager:${name}`);
        this.player = player;
    }
}

class OptionNamespace {
    addItem(opts) {
        this._items.add(opts);
        return this;
    }
    applyPlayer(player) {
        if (this.players.has(player)) return this.players.get(player);
        const playerOpt = new PlayerOption(player, this.name);
        each(this._items, (item)=>{
            item._player = player;
            playerOpt.addItem(item);
        });
        this.players.set(player, playerOpt);
        return playerOpt;
    }
    async applyMainPlayer() {
        const player = await waitForFirstPlayerInitialSpawn();
        return this.applyPlayer(player);
    }
    async init() {
        const valueMap = new Map();
        await eachAsync(this.players, async ([player, playerOpt])=>{
            const result = await playerOpt.init();
            valueMap.set(player, result);
        });
        this.applyPlayer = undefined;
        return valueMap;
    }
    getPlayer(player) {
        return this.players.get(player);
    }
    constructor(name){
        this.players = new Map();
        this._items = new Set();
        this.name = name;
    }
}

class OptionManager {
    registerNamesapace(name) {
        const namespaces = new OptionNamespace(name);
        this.namespaces.set(name, namespaces);
        return namespaces;
    }
    getNamesapace(name) {
        return this.namespaces.get(name);
    }
    async showDialog(player) {
        const form = new ActionFormData().title("设置选项").body("选择要设置的模块：");
        const nameMap = [];
        each(this.namespaces, ([name])=>{
            nameMap.push(name);
            form.button(name) // TODO name -> desc
            ;
        });
        const dialog = new Dialog({
            dialog: form,
            onSelect: async (selection)=>{
                const name = nameMap[selection];
                await this.getNamesapace(name).getPlayer(player).showDialog(dialog);
            }
        });
        await dialog.show(player);
    }
    constructor(){
        this.namespaces = new Map();
    }
}

const optionManager = new OptionManager();

Commands.register("!", "option", async (argv, sender)=>{
    switch(argv[1]){
        case "dialog":
        case "-d":
        case undefined:
            {
                // TODO argv[2] -> namespace
                await asyncRun(()=>optionManager.showDialog(sender));
                break;
            }
        default:
            {
                throw errorHandler("未知的子命令", sender);
            }
    }
});

const option = optionManager.registerNamesapace("scoreboard-statistic").addItem({
    name: "enable_creative",
    description: "允许统计创造模式下的行为",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: true,
    events: {
        changed: (selected, original)=>console.warn("scoreboard-statistic:enable_creative -> from", original, "to", selected)
    }
}).addItem({
    name: "enable_cancel_out",
    description: "对部分统计项启用抵消",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: false,
    events: {
        changed: (selected, original)=>console.warn("scoreboard-statistic:enable_cancel_out -> from", original, "to", selected)
    }
}).addItem({
    name: "enable_confirm_dialog",
    description: "启用删除记分板时的警告",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: true,
    events: {
        changed: (selected, original)=>console.warn("scoreboard-statistic:enable_confirm_dialog -> from", original, "to", selected)
    }
}).addItem({
    name: "auto_start",
    description: "添加记分板后是否自动开始统计",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: true,
    events: {
        changed: (selected, original)=>console.warn("scoreboard-statistic:auto_start -> from", original, "to", selected)
    }
});

var killed = (({ player, target, callback })=>({
        events: {
            entityDie: {
                option: {
                    entityTypes: [
                        target
                    ]
                },
                listener (event) {
                    const cause = event.damageSource.cause;
                    const source = event.damageSource.damagingEntity;
                    if (cause === EntityDamageCause.entityAttack && source.id === player.id) callback({
                        type: "increase",
                        value: 1
                    });
                }
            }
        }
    }));

var killed_by = (({ player, target, callback })=>({
        events: {
            entityDie: {
                option: {
                    entities: [
                        player
                    ]
                },
                listener (event) {
                    const cause = event.damageSource.cause;
                    const source = event.damageSource.damagingEntity;
                    if (cause === EntityDamageCause.entityAttack && source.typeId === target) callback({
                        type: "increase",
                        value: 1
                    });
                }
            }
        }
    }));

var killed_for = (({ player, target, callback })=>({
        events: {
            entityDie: {
                option: {
                    entities: [
                        player
                    ]
                },
                listener (event) {
                    const cause = `minecraft:${event.damageSource.cause}`;
                    if (cause === target) callback({
                        type: "increase",
                        value: 1
                    });
                }
            }
        }
    }));

var mined = (({ player, target, callback })=>({
        events: {
            playerBreakBlock: {
                listener (event) {
                    const blockPermutation = event.brokenBlockPermutation;
                    const source = event.player;
                    if (source.id === player.id && blockPermutation.type.id === target) callback({
                        type: "increase",
                        value: 1
                    });
                }
            },
            playerPlaceBlock: {
                listener (event) {
                    const block = event.block;
                    const source = event.player;
                    if (source.id === player.id && block.typeId === target) callback({
                        type: "decrease",
                        value: 1
                    });
                }
            }
        }
    }));

var placed = (({ player, target, callback })=>({
        events: {
            playerBreakBlock: {
                listener (event) {
                    const blockPermutation = event.brokenBlockPermutation;
                    const source = event.player;
                    if (source.id === player.id && blockPermutation.type.id === target) callback({
                        type: "decrease",
                        value: 1
                    });
                }
            },
            playerPlaceBlock: {
                listener (event) {
                    const block = event.block;
                    const source = event.player;
                    if (source.id === player.id && block.typeId === target) callback({
                        type: "increase",
                        value: 1
                    });
                }
            }
        }
    }));

// import custom from "./custom/index"
const types = {
    // custom
    // TODO
    // "minecraft:custom": custom, custom,
    // mob
    "minecraft:killed": killed,
    killed,
    "minecraft:killed_by": killed_by,
    killed_by,
    "minecraft:killed_for": killed_for,
    killed_for,
    // block
    "minecraft:mined": mined,
    mined,
    "minecraft:placed": placed,
    placed
};

var deathCount = (({ player, callback })=>({
        events: {
            entityDie: {
                option: {
                    entities: [
                        player
                    ]
                },
                listener () {
                    callback({
                        type: "increase",
                        value: 1
                    });
                }
            }
        }
    }));

var health = (({ player, callback })=>({
        events: {
            entityHealthChanged: {
                option: {
                    entities: [
                        player
                    ]
                },
                listener (event) {
                    callback({
                        type: "reset",
                        value: event.newValue
                    });
                }
            },
            playerSpawn: {
                listener () {
                    callback({
                        type: "reset",
                        value: 20
                    });
                }
            }
        }
    }));

var playerKillCount = (({ player, callback })=>killed({
        player,
        target: "minecraft:player",
        callback
    }));

var totalKillCount = (({ player, callback })=>({
        events: {
            entityDie: {
                listener (event) {
                    const cause = event.damageSource.cause;
                    const source = event.damageSource.damagingEntity;
                    if (cause === EntityDamageCause.entityAttack && source.id === player.id) callback({
                        type: "increase",
                        value: 1
                    });
                }
            }
        }
    }));

// @ts-ignore
var CRITERIA = new Map([
    ...Object.entries(types),
    [
        "deathCount",
        deathCount
    ],
    [
        "playerKillCount",
        playerKillCount
    ],
    [
        "totalKillCount",
        totalKillCount
    ],
    [
        "health",
        health
    ]
]);

class Handler {
    async add({ objectiveId, criteria, displayName = objectiveId }) {
        if (world.scoreboard.getObjective(objectiveId)) return {
            code: 0,
            message: "DUPLICATE_OBJECTIVE"
        };
        const [criteriaType] = parseCriteria(criteria);
        if (!CRITERIA.get(criteriaType)) return {
            code: 0,
            message: "UNKNOWN_CRITERIA"
        };
        await asyncRun(()=>{
            const objective = world.scoreboard.addObjective(objectiveId, displayName);
            world.scoreboard.setObjectiveAtDisplaySlot(DisplaySlotId.Sidebar, {
                objective,
                sortOrder: ObjectiveSortOrder.Ascending
            });
            if (!objective.hasParticipant(this.player)) {
                // TODO: 或许放到 start 里更合理
                // 如果该玩家不存在任何一个记分板中，直接 setScore(this.player) 会报错
                // 所以这里用命令设置一下初始分数
                // objective.setScore(this.player, 0)
                this.player.runCommand(`scoreboard players set @s ${objectiveId} 0`);
            }
        });
        await globalDB.set(objectiveId, criteria);
        return {
            code: 1
        };
    }
    async remove({ objectiveId }) {
        if (!globalDB.get(objectiveId)) return false;
        await asyncRun(()=>world.scoreboard.removeObjective(objectiveId));
        await globalDB.delete(objectiveId);
        return true;
    }
    async start({ objectiveId, criteria = globalDB.get(objectiveId) }) {
        if (this.playerDB.has(objectiveId)) return false;
        const objective = getOrAddObjective(objectiveId);
        const [criteriaType, criteriaName] = parseCriteria(criteria);
        const setupTigger = CRITERIA.get(criteriaType);
        const tigger = setupTigger({
            player: this.player,
            target: criteriaName,
            callback: (result)=>{
                if (// @ts-ignore
                !WrappedPlayer.wrap(this.player).testGameMode(GameMode.creative) || this.playerOption.getItemVal("enable_creative")) {
                    switch(result.type){
                        case "decrease":
                            {
                                if (this.playerOption.getItemVal("enable_cancel_out")) objective.setScore(this.player, objective.getScore(this.player) - result.value);
                                break;
                            }
                        case "reset":
                            {
                                objective.setScore(this.player, result.value);
                                break;
                            }
                        default:
                            {
                                // TODO: scoreboard wrapper #addScore()
                                objective.setScore(this.player, objective.getScore(this.player) + result.value);
                            }
                    }
                }
            }
        });
        await eachAsync(tigger.events, async ({ option: subscribeOption, listener }, eventName)=>{
            if (subscribeOption) await asyncRun(()=>world.afterEvents[eventName].subscribe(listener, subscribeOption));
            else await asyncRun(()=>world.afterEvents[eventName].subscribe(listener)) // 为什么多传参数还报错啊啊啊啊啊啊啊！！！
            ;
        });
        await this.playerDB.add(objectiveId, tigger.events);
        return true;
    }
    async stop({ objectiveId }) {
        if (!this.playerDB.has(objectiveId)) return false;
        const events = this.playerDB.getEvents(objectiveId);
        await eachAsync(events, async ({ listener }, eventName)=>{
            await asyncRun(()=>world.afterEvents[eventName].unsubscribe(listener));
        });
        await this.playerDB.delete(objectiveId);
        return true;
    }
    constructor(player){
        this.player = player;
        this.playerOption = option.getPlayer(player);
        this.playerDB = ALL_PLAYER_DATABASES.get(player);
    }
}
function parseCriteria(criteria) {
    return criteria.split(":").map((e)=>e.replace(".", ":")).map((e, i)=>{
        if (i === 0) return e;
        return e.match(/^(.+)\:/) ? e : `minecraft:${e}`;
    });
}

async function command(argv, sender) {
    const playerOption = option.getPlayer(sender);
    const handler = new Handler(sender);
    const objectiveId = argv[2];
    switch(argv[1]){
        case "add":
            {
                const [, , , criteria, displayName] = argv;
                if (!objectiveId) throw errorHandler("objectiveId 是必须的", sender);
                if (!criteria) throw errorHandler("criteria 是必须的", sender);
                if (!playerOption.getItemVal("enable_creative")) sender.sendMessage("注意：当前设置不会统计创造模式下的行为");
                const result = await handler.add({
                    objectiveId,
                    criteria,
                    displayName
                });
                if (result.code) sender.sendMessage(`成功添加记分板 "${displayName}" (${objectiveId}) 使用 "${criteria}"`);
                else {
                    switch(result.message){
                        case "DUPLICATE_OBJECTIVE":
                            {
                                throw errorHandler(`添加失败：记分板 ${objectiveId} 已存在`, sender);
                            }
                        case "UNKNOWN_CRITERIA":
                            {
                                throw errorHandler(`添加失败：未知的准则 ${criteria}`, sender);
                            }
                    }
                }
                if (playerOption.getItemVal("auto_start")) {
                    const startResult = await handler.start({
                        objectiveId,
                        criteria
                    });
                    if (startResult) sender.sendMessage(`已自动开启您在 ${displayName} 上的统计`);
                }
                break;
            }
        case "remove":
        case "rm":
        case "-r":
            {
                async function _remove() {
                    const result = await handler.remove({
                        objectiveId
                    });
                    if (result) sender.sendMessage(`删除成功 ${objectiveId}`);
                    else throw errorHandler(`移除失败：记分板 ${objectiveId} 不存在或不是统计用记分板`, sender);
                }
                if (playerOption.getItemVal("enable_confirm_dialog")) await Dialog.confirm({
                    body: `是否清除记分板 ${objectiveId} 上的统计数据，你将永远失去它们`,
                    target: sender,
                    onConfirm: _remove
                });
                else await _remove();
                break;
            }
        case "stop":
            {
                const result = await handler.stop({
                    objectiveId
                });
                if (result) sender.sendMessage(`已暂停您在 ${objectiveId} 上的统计`);
                else throw errorHandler(`暂停失败：您可能没有开启您在记分板 ${objectiveId} 上的统计，或该记分板不存在`, sender);
                break;
            }
        case "start":
            {
                const result = await handler.start({
                    objectiveId
                });
                if (result) sender.sendMessage(`已开启您在 ${objectiveId} 上的统计`);
                else throw errorHandler(`开启失败：您可能已经开启您在记分板 ${objectiveId} 上的统计，或该记分板不存在`, sender);
                break;
            }
        case "option":
        case "opt":
        case "-o":
            {
                await asyncRun(()=>playerOption.showDialog());
                break;
            }
        default:
            {
                throw errorHandler(`未知的子命令 ${argv[1]}`, sender);
            }
    }
}

option.applyMainPlayer().then(()=>each(world.getAllPlayers(), (player)=>option.applyPlayer(player))).then(()=>option.init()).then(async ()=>{
    await eachAsync(option.players, async ([player])=>{
        // 将所有玩家的数据库实例化并储存在 ALL_PLAYER_DATABASES 中
        const db = EventDB.init(player);
        const handler = new Handler(player);
        const participated = db.getParticipated();
        // reload 后运行时存储 events 为空，
        // 并且 listener 也都失效，
        // 故重新订阅事件
        await db.clear();
        await eachAsync(participated, async (objectiveId)=>{
            const result = await handler.start({
                objectiveId
            });
            if (result) player.sendMessage(`已重启您在记分板 ${objectiveId} 上的统计`);
        });
    });
    Commands.register("!", "statistic", command);
}).catch(BetterConsole.error);
//# sourceMappingURL=scoreboard-statistic.js.map
