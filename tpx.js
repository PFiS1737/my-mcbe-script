/*!
 * my-mcbe-script-tpx.js v0.0.0 (https://github.com/PFiS1737/my-mcbe-script#readme)
 * Copyright 2022-2024 PFiS1737
 * Licensed under MIT
 *
 * This file is automatically generated, please do not change it.
 */
import { world, MinecraftDimensionTypes, Dimension, Entity, system } from '@minecraft/server';
import { MessageFormData, FormCancelationReason, ModalFormResponse, MessageFormResponse, ActionFormResponse, ModalFormData, ActionFormData } from '@minecraft/server-ui';

class BetterConsole {
    static error(err) {
        console.error(`${err}\n${err.stack}`);
    }
}

function each(target, callbackfn, thisArg) {
    if (Array.isArray(target)) target.forEach(callbackfn, thisArg);
    else if (target?.[Symbol.iterator]) for (const item of target)callbackfn.call(thisArg, item, target);
    else if (typeof target === "object") each(Object.keys(target), (key, i)=>callbackfn.call(thisArg, target[key], key, i, target));
}
async function eachAsync(target, asyncfn, thisArg) {
    if (Array.isArray(target)) for(let i = 0; i < target.length; i++)await asyncfn.call(thisArg, target[i], i, target);
    else if (target?.[Symbol.iterator]) for (const item of target)await asyncfn.call(thisArg, item, target);
    else if (typeof target === "object") await eachAsync(Object.keys(target), async (key, i)=>await asyncfn.call(thisArg, target[key], key, i, target));
}
function safeEval(code, context = {}) {
    const fn = new Function(...Object.keys(context), `return ${code}`);
    return fn(...Object.values(context));
}
function serialize(obj) {
    if (obj instanceof Set) return `new Set(${serialize(Array.from(obj))})`;
    if (obj instanceof Map) return `new Map(${serialize(Array.from(obj.entries()))})`;
    if (Array.isArray(obj)) return `[${obj.map(serialize).join(",")}]`;
    if (typeof obj === "object" && obj !== null) {
        return `{${Object.entries(obj).map(([key, value])=>`${serialize(key)}: ${serialize(value)}`).join(",")}}`;
    }
    return JSON.stringify(obj);
}
function deserialize(str) {
    try {
        return JSON.parse(str);
    } catch (err) {
        // console.warn(`Could not use \`JSON.parse()\` to deserialise the string, trying \`safeEval()\`.`, { string: str })
        return safeEval(`(${str})`);
    }
}
function isAsyncFunc(func) {
    return Object.prototype.toString.call(func) === "[object AsyncFunction]";
}

const overworld = world.getDimension(MinecraftDimensionTypes.overworld);
const CUSTOM_COMMAND_SET = new Set();
class Commands {
    static run(commandString, target = overworld) {
        // @ts-ignore
        if (target instanceof Dimension || target instanceof Entity) return target.runCommand(commandString);
        throw new TypeError("Target must be Entity or Dimension.");
    }
    static async asyncRun(commandString, target = overworld) {
        // @ts-ignore
        if (target instanceof Dimension || target instanceof Entity) {
            const customCommands = [
                ...CUSTOM_COMMAND_SET
            ].filter(({ regex })=>regex.test(commandString)).map((e)=>e.runner);
            if (customCommands.length) await eachAsync(customCommands, async (runner)=>await runner(commandString, target));
            else return await target.runCommandAsync(commandString);
        } else throw new TypeError("Target must be Entity or Dimension.");
    }
    static register(prefix, command, callback) {
        if (prefix.startsWith("/")) throw new Error("Unable to register slash commands.");
        const regex = new RegExp(`^${prefix}${command}( |$)`);
        const runner = async (commandString, target)=>{
            const argv = commandString.split(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g).filter((e)=>e.trim().length > 0);
            await callback(argv, target);
        };
        CUSTOM_COMMAND_SET.add({
            regex,
            runner
        });
        world.beforeEvents.chatSend.subscribe((event)=>{
            if (regex.test(event.message)) {
                event.cancel = true;
                runner(event.message, event.sender).catch(BetterConsole.error);
            }
        });
    }
}

function asyncRun(fn) {
    return new Promise((resolve, reject)=>{
        system.run(()=>{
            try {
                resolve(fn());
            } catch (err) {
                reject(err);
            }
        });
    });
}
function errorHandler(errText, target) {
    const err = new Error(errText);
    target.sendMessage(err.toString());
    return err;
}
function waitForFirstPlayerInitialSpawn() {
    const players = world.getAllPlayers();
    if (players.length) return Promise.resolve(players[0]);
    return new Promise((resolve)=>{
        const callback = world.afterEvents.playerSpawn.subscribe((event)=>{
            if (event.initialSpawn) resolve(event.player);
            world.afterEvents.playerSpawn.unsubscribe(callback);
        });
    });
}
function getOrAddObjective(id, name) {
    const objective = world.scoreboard.getObjective(id);
    if (!objective && !name) throw new Error(`Couldn't find objective "${id}".`);
    if (!objective) return world.scoreboard.addObjective(id, name);
    return objective;
}
function removeMinecraftNamespace(identifier) {
    return identifier.replace(/^minecraft\:/, "");
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var md5$1 = {exports: {}};

var crypt = {exports: {}};

(function() {
    var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', crypt$1 = {
        // Bit-wise rotation left
        rotl: function(n, b) {
            return n << b | n >>> 32 - b;
        },
        // Bit-wise rotation right
        rotr: function(n, b) {
            return n << 32 - b | n >>> b;
        },
        // Swap big-endian to little-endian and vice versa
        endian: function(n) {
            // If number given, swap endian
            if (n.constructor == Number) {
                return crypt$1.rotl(n, 8) & 0x00FF00FF | crypt$1.rotl(n, 24) & 0xFF00FF00;
            }
            // Else, assume array and swap all items
            for(var i = 0; i < n.length; i++)n[i] = crypt$1.endian(n[i]);
            return n;
        },
        // Generate an array of any length of random bytes
        randomBytes: function(n) {
            for(var bytes = []; n > 0; n--)bytes.push(Math.floor(Math.random() * 256));
            return bytes;
        },
        // Convert a byte array to big-endian 32-bit words
        bytesToWords: function(bytes) {
            for(var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)words[b >>> 5] |= bytes[i] << 24 - b % 32;
            return words;
        },
        // Convert big-endian 32-bit words to a byte array
        wordsToBytes: function(words) {
            for(var bytes = [], b = 0; b < words.length * 32; b += 8)bytes.push(words[b >>> 5] >>> 24 - b % 32 & 0xFF);
            return bytes;
        },
        // Convert a byte array to a hex string
        bytesToHex: function(bytes) {
            for(var hex = [], i = 0; i < bytes.length; i++){
                hex.push((bytes[i] >>> 4).toString(16));
                hex.push((bytes[i] & 0xF).toString(16));
            }
            return hex.join('');
        },
        // Convert a hex string to a byte array
        hexToBytes: function(hex) {
            for(var bytes = [], c = 0; c < hex.length; c += 2)bytes.push(parseInt(hex.substr(c, 2), 16));
            return bytes;
        },
        // Convert a byte array to a base-64 string
        bytesToBase64: function(bytes) {
            for(var base64 = [], i = 0; i < bytes.length; i += 3){
                var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
                for(var j = 0; j < 4; j++)if (i * 8 + j * 6 <= bytes.length * 8) base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 0x3F));
                else base64.push('=');
            }
            return base64.join('');
        },
        // Convert a base-64 string to a byte array
        base64ToBytes: function(base64) {
            // Remove non-base-64 characters
            base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');
            for(var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4){
                if (imod4 == 0) continue;
                bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
            }
            return bytes;
        }
    };
    crypt.exports = crypt$1;
})();

var cryptExports = crypt.exports;

var charenc = {
    // UTF-8 encoding
    utf8: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
            return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
            return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
        }
    },
    // Binary encoding
    bin: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
            for(var bytes = [], i = 0; i < str.length; i++)bytes.push(str.charCodeAt(i) & 0xFF);
            return bytes;
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
            for(var str = [], i = 0; i < bytes.length; i++)str.push(String.fromCharCode(bytes[i]));
            return str.join('');
        }
    }
};
var charenc_1 = charenc;

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
var isBuffer_1 = function(obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}
// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

(function() {
    var crypt = cryptExports, utf8 = charenc_1.utf8, isBuffer = isBuffer_1, bin = charenc_1.bin, // The core
    md5 = function(message, options) {
        // Convert to byte array
        if (message.constructor == String) if (options && options.encoding === 'binary') message = bin.stringToBytes(message);
        else message = utf8.stringToBytes(message);
        else if (isBuffer(message)) message = Array.prototype.slice.call(message, 0);
        else if (!Array.isArray(message) && message.constructor !== Uint8Array) message = message.toString();
        // else, assume byte array already
        var m = crypt.bytesToWords(message), l = message.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
        // Swap endian
        for(var i = 0; i < m.length; i++){
            m[i] = (m[i] << 8 | m[i] >>> 24) & 0x00FF00FF | (m[i] << 24 | m[i] >>> 8) & 0xFF00FF00;
        }
        // Padding
        m[l >>> 5] |= 0x80 << l % 32;
        m[(l + 64 >>> 9 << 4) + 14] = l;
        // Method shortcuts
        var FF = md5._ff, GG = md5._gg, HH = md5._hh, II = md5._ii;
        for(var i = 0; i < m.length; i += 16){
            var aa = a, bb = b, cc = c, dd = d;
            a = FF(a, b, c, d, m[i + 0], 7, -680876936);
            d = FF(d, a, b, c, m[i + 1], 12, -389564586);
            c = FF(c, d, a, b, m[i + 2], 17, 606105819);
            b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
            a = FF(a, b, c, d, m[i + 4], 7, -176418897);
            d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
            c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
            b = FF(b, c, d, a, m[i + 7], 22, -45705983);
            a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
            d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
            c = FF(c, d, a, b, m[i + 10], 17, -42063);
            b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
            a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
            d = FF(d, a, b, c, m[i + 13], 12, -40341101);
            c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
            b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
            a = GG(a, b, c, d, m[i + 1], 5, -165796510);
            d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
            c = GG(c, d, a, b, m[i + 11], 14, 643717713);
            b = GG(b, c, d, a, m[i + 0], 20, -373897302);
            a = GG(a, b, c, d, m[i + 5], 5, -701558691);
            d = GG(d, a, b, c, m[i + 10], 9, 38016083);
            c = GG(c, d, a, b, m[i + 15], 14, -660478335);
            b = GG(b, c, d, a, m[i + 4], 20, -405537848);
            a = GG(a, b, c, d, m[i + 9], 5, 568446438);
            d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
            c = GG(c, d, a, b, m[i + 3], 14, -187363961);
            b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
            a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
            d = GG(d, a, b, c, m[i + 2], 9, -51403784);
            c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
            b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
            a = HH(a, b, c, d, m[i + 5], 4, -378558);
            d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
            c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
            b = HH(b, c, d, a, m[i + 14], 23, -35309556);
            a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
            d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
            c = HH(c, d, a, b, m[i + 7], 16, -155497632);
            b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
            a = HH(a, b, c, d, m[i + 13], 4, 681279174);
            d = HH(d, a, b, c, m[i + 0], 11, -358537222);
            c = HH(c, d, a, b, m[i + 3], 16, -722521979);
            b = HH(b, c, d, a, m[i + 6], 23, 76029189);
            a = HH(a, b, c, d, m[i + 9], 4, -640364487);
            d = HH(d, a, b, c, m[i + 12], 11, -421815835);
            c = HH(c, d, a, b, m[i + 15], 16, 530742520);
            b = HH(b, c, d, a, m[i + 2], 23, -995338651);
            a = II(a, b, c, d, m[i + 0], 6, -198630844);
            d = II(d, a, b, c, m[i + 7], 10, 1126891415);
            c = II(c, d, a, b, m[i + 14], 15, -1416354905);
            b = II(b, c, d, a, m[i + 5], 21, -57434055);
            a = II(a, b, c, d, m[i + 12], 6, 1700485571);
            d = II(d, a, b, c, m[i + 3], 10, -1894986606);
            c = II(c, d, a, b, m[i + 10], 15, -1051523);
            b = II(b, c, d, a, m[i + 1], 21, -2054922799);
            a = II(a, b, c, d, m[i + 8], 6, 1873313359);
            d = II(d, a, b, c, m[i + 15], 10, -30611744);
            c = II(c, d, a, b, m[i + 6], 15, -1560198380);
            b = II(b, c, d, a, m[i + 13], 21, 1309151649);
            a = II(a, b, c, d, m[i + 4], 6, -145523070);
            d = II(d, a, b, c, m[i + 11], 10, -1120210379);
            c = II(c, d, a, b, m[i + 2], 15, 718787259);
            b = II(b, c, d, a, m[i + 9], 21, -343485551);
            a = a + aa >>> 0;
            b = b + bb >>> 0;
            c = c + cc >>> 0;
            d = d + dd >>> 0;
        }
        return crypt.endian([
            a,
            b,
            c,
            d
        ]);
    };
    // Auxiliary functions
    md5._ff = function(a, b, c, d, x, s, t) {
        var n = a + (b & c | ~b & d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
    };
    md5._gg = function(a, b, c, d, x, s, t) {
        var n = a + (b & d | c & ~d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
    };
    md5._hh = function(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
    };
    md5._ii = function(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
    };
    // Package private blocksize
    md5._blocksize = 16;
    md5._digestsize = 16;
    md5$1.exports = function(message, options) {
        if (message === undefined || message === null) throw new Error('Illegal argument ' + message);
        var digestbytes = crypt.wordsToBytes(md5(message, options));
        return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
    };
})();

var md5Exports = md5$1.exports;
var md5 = /*@__PURE__*/getDefaultExportFromCjs(md5Exports);

const ALL_DATABASES = new Map();
class Database {
    static open(player, dbName) {
        return new Database(player, dbName);
    }
    _syncDataFromScoreboard() {
        this.store.clear();
        each(this.objective.getParticipants(), (participant)=>{
            const data = deserialize(participant.displayName);
            const key = Object.keys(data)[0];
            const value = data[key];
            this.store.set(key, {
                value,
                participant
            });
        });
    }
    has(key) {
        return this.store.has(key);
    }
    async delete(key) {
        if (this.has(key)) {
            const { participant } = this.store.get(key);
            await asyncRun(()=>this.objective.removeParticipant(participant));
            this.store.delete(key);
            return true;
        }
        return false;
    }
    async clear() {
        await eachAsync(this.store, async ([, { participant }])=>await asyncRun(()=>this.objective.removeParticipant(participant)));
        this.store.clear();
    }
    get(key) {
        return this.store.get(key)?.value;
    }
    async set(key, value) {
        await this.delete(key);
        const data = serialize({
            [key]: value
        }).replaceAll('"', "'");
        // FIXME: has ambiguity
        if (data.length > 32767) throw new RangeError("Database: Only accepts a string value less than 32767 characters.");
        await asyncRun(()=>this.objective.setScore(data, 1));
        this._syncDataFromScoreboard();
    }
    getAll() {
        const output = {};
        for (const [key, value] of this)output[key] = value;
        return output;
    }
    *entries() {
        for (const [key, { value }] of this.store.entries())yield [
            key,
            value
        ];
    }
    *keys() {
        for (const key of this.store.keys())yield key;
    }
    *values() {
        for (const { value } of this.store.values())yield value;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    constructor(player, dbName){
        this.store = new Map();
        const id = md5(`db:${dbName}_${player.id}`).slice(8, 24);
        this.id = id;
        this.objective = getOrAddObjective(id, `db:${dbName}`);
        // this.player = player
        // if (!(player instanceof Player)) this.fakePlayer = true
        this._syncDataFromScoreboard();
        ALL_DATABASES.set(id, this);
    }
}

class Dialog {
    static async confirm({ title = "确认", body, target, onCancel = async ()=>({}), onConfirm = async ()=>({}) }) {
        if (!body || !target) throw new Error();
        const form = await asyncRun(()=>{
            return new Dialog({
                dialog: new MessageFormData().title(title).body(body).button1("CANCEL").button2("OK"),
                onClose: onCancel,
                onSelectButton1: onCancel,
                onSelectButton2: onConfirm
            });
        });
        return await form.show(target);
    }
    async show(target) {
        let response;
        target.sendMessage("[!] 新对话框已发送，请关闭命令输入栏或其他对话框");
        do {
            response = await this.dialog.show(target);
        }while (response.cancelationReason === FormCancelationReason.UserBusy)
        if (response.canceled && response.cancelationReason === FormCancelationReason.UserClosed) return await this.onClose();
        if (response instanceof ModalFormResponse) {
            if (!response.formValues) throw new Error("Unexpected error.");
            return await this.onSubmit(response.formValues);
        }
        if (response instanceof MessageFormResponse) {
            if (response.selection === 0) return await this.onSelectButton1();
            if (response.selection === 1) return await this.onSelectButton2();
            throw new Error("Unexpected error.");
        }
        if (response instanceof ActionFormResponse) {
            if (!response.selection) throw new Error("Unexpected error.");
            return await this.onSelect(response.selection);
        }
    }
    constructor({ dialog, onClose = async ()=>({}), onSubmit = async ()=>({}), onSelectButton1 = async ()=>({}), onSelectButton2 = async ()=>({}), onSelect = async ()=>({}) }){
        this.dialog = dialog;
        this.onSubmit = onSubmit;
        this.onSelectButton1 = onSelectButton1;
        this.onSelectButton2 = onSelectButton2;
        this.onSelect = onSelect;
        this.onClose = onClose;
    }
}

function round(n) {
    if (n >= 0) return Math.round(n);
    return n % 0.5 === 0 ? Math.floor(n) : Math.round(n);
}
function equals(a, b, epsilon = 0.000001) {
    return Math.abs(a - b) <= epsilon * Math.max(1, Math.abs(a), Math.abs(b));
}
function range(from, to, step = 1) {
    const output = [];
    for(let i = from; i < to; i += step)output.push(i);
    return output;
}

/**
 * Class representing an N-dimensional vector.
 */ class VectorN {
    get x() {
        return this.get(0);
    }
    set x(value) {
        this.set(0, value);
    }
    get y() {
        return this.get(1);
    }
    set y(value) {
        this.set(1, value);
    }
    get z() {
        return this.get(2);
    }
    set z(value) {
        this.set(2, value);
    }
    get w() {
        return this.get(3);
    }
    set w(value) {
        this.set(3, value);
    }
    /**
   * Create a vector.
   * @param vector - The vector wrote in array or string.
   * @returns The vector.
   */ static create(vector) {
        if (Array.isArray(vector)) return new this(...vector);
        if (typeof vector === "string") return this.parse(vector);
        throw new Error(`Can't create vector for ${serialize(vector)}`);
    }
    /**
   * Parse a string to vector.
   * @param vectorStr - The string to parse.
   * @returns The vector.
   */ static parse(vectorStr) {
        return this.create(vectorStr.split(" ").map(Number));
    }
    /**
   * Convert the vector to a string.
   * @returns The string representation of the vector.
   */ stringify() {
        // @ts-ignore
        return this[Symbol.toPrimitive]("string");
    }
    /**
   * Convert the vector to an array.
   * @returns The array representation of the vector.
   */ toArray() {
        return [
            ...this
        ];
    }
    /**
   * Convert the vector to a primitive value.
   * @param hint - The type hint.
   * @returns The string representation or the vector itself.
   */ [Symbol.toPrimitive](hint) {
        if (hint === "string") return this.axes.join(" ");
        return this;
    }
    /**
   * Iterator for the vector axes.
   * @returns The iterator for the axes.
   */ [Symbol.iterator]() {
        return this.axes[Symbol.iterator]();
    }
    /**
   * Get the number of dimensions of the vector.
   * @returns The number of dimensions.
   */ get dimensions() {
        return this.axes.length;
    }
    /**
   * Get an axis of the vector by index.
   * @param index - The index of the component.
   * @returns The component value.
   */ get(index) {
        return this.axes[index];
    }
    /**
   * Set an axis of the vector by index.
   * @param index - The index of the component.
   * @param value - The value to set.
   */ set(index, value) {
        this.axes[index] = value;
    }
    /**
   * Apply a function to each axes of the vector and return a new vector.
   * @param callbackfn - The function to apply.
   * @returns The new vector.
   */ map(callbackfn) {
        return VectorN.create(this.axes.map(callbackfn));
    }
    /**
   * Create a vector.
   * @param axes - The axes of the vector.
   */ constructor(...axes){
        this.axes = axes;
    }
}

/**
 * Utility class for operations on N-dimensional vectors.
 */ class VectorNUtils {
    /**
   * Create a vector.
   * @param vector - The vector write in array.
   * @returns The vector.
   */ static create(vector) {
        return VectorN.create(vector);
    }
    /**
   * Clone a vector.
   * @param a - The vector to clone.
   * @returns The cloned vector.
   */ static clone(a) {
        return this.create(a.toArray());
    }
    /**
   * Assert that two vectors have the same dimensions.
   * @param a - The first vector.
   * @param b - The second vector.
   * @throws Will throw an error if the vectors do not have the same dimensions.
   */ static _assertDimensions(a, b) {
        if (a.dimensions !== b.dimensions) throw new Error("Vectors must have the same dimensions.");
    }
    /**
   * Add two vectors.
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns The resulting vector.
   */ static add(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val + b.get(index));
    }
    /**
   * Subtract one vector from another.
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns The resulting vector.
   */ static subtract(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val - b.get(index));
    }
    /**
   * Multiply two vectors component-wise.
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns The resulting vector.
   */ static multiply(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val * b.get(index));
    }
    /**
   * Divide one vector by another component-wise.
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns The resulting vector.
   */ static divide(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val / b.get(index));
    }
    /**
   * Scale a vector by a scalar.
   * @param a - The vector to scale.
   * @param n - The scalar value.
   * @returns The resulting vector.
   */ static scale(a, n) {
        return a.map((val)=>val * n);
    }
    /**
   * Negate a vector.
   * @param a - The vector to negate.
   * @returns The resulting vector.
   */ static negate(a) {
        return a.map((val)=>-val);
    }
    /**
   * Invert a vector component-wise.
   * @param a - The vector to invert.
   * @returns The resulting vector.
   */ static inverse(a) {
        return a.map((val)=>1 / val);
    }
    /**
   * Exchange two axes of a vector.
   * @param a - The vector to modify.
   * @param axis1 - The first axis to exchange.
   * @param axis2 - The second axis to exchange
   * @returns The resulting vector.
   * @throws Will throw an error if the length of the axes array is not 2.
   */ static exchange(a, axis1, axis2) {
        const output = this.clone(a);
        const n0 = output.get(axis1);
        const n1 = output.get(axis2);
        output.set(axis1, n1);
        output.set(axis2, n0);
        return output;
    }
    /**
   * Check if two vectors are exactly equal.
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are exactly equal, otherwise false.
   */ static exactEquals(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.axes.every((val, index)=>val === b.get(index));
    }
    /**
   * Check if two vectors are approximately equal.
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are approximately equal, otherwise false.
   */ static equals(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.axes.every((val, index)=>equals(val, b.get(index)));
    }
    /**
   * Get the component-wise maximum of multiple vectors.
   * @param vectors - The vectors to compare.
   * @returns The resulting vector.
   */ static max(...vectors) {
        const length = vectors[0].dimensions;
        const maxAxes = vectors.reduce((acc, vector)=>{
            vector.axes.forEach((val, index)=>{
                if (val > acc[index]) acc[index] = val;
            });
            return acc;
        }, new Array(length).fill(Number.NEGATIVE_INFINITY));
        return this.create(maxAxes);
    }
    /**
   * Get the component-wise minimum of multiple vectors.
   * @param vectors - The vectors to compare.
   * @returns The resulting vector.
   */ static min(...vectors) {
        const length = vectors[0].dimensions;
        const minAxes = vectors.reduce((acc, vector)=>{
            vector.axes.forEach((val, index)=>{
                if (val < acc[index]) acc[index] = val;
            });
            return acc;
        }, new Array(length).fill(Number.POSITIVE_INFINITY));
        return this.create(minAxes);
    }
    /**
   * Apply the floor function to each component of a vector.
   * @param a - The vector to modify.
   * @returns The resulting vector.
   */ static floor(a) {
        return a.map((val)=>Math.floor(val));
    }
    /**
   * Apply the ceil function to each component of a vector.
   * @param a - The vector to modify.
   * @returns The resulting vector.
   */ static ceil(a) {
        return a.map((val)=>Math.ceil(val));
    }
    /**
   * Apply the round function to each component of a vector.
   * @param a - The vector to modify.
   * @returns The resulting vector.
   */ static round(a) {
        return a.map((val)=>round(val));
    }
    /**
   * Apply the absolute value function to each component of a vector.
   * @param a - The vector to modify.
   * @returns The resulting vector.
   */ static abs(a) {
        return a.map((val)=>Math.abs(val));
    }
    /**
   * Get the vector with the maximum magnitude from a list of vectors.
   * @param vectors - The vectors to compare.
   * @returns The vector with the maximum magnitude.
   */ static maxMagnitude(...vectors) {
        return vectors.reduce((prev, curr)=>VectorNUtils.magnitude(curr) > VectorNUtils.magnitude(prev) ? curr : prev);
    }
    /**
   * Get the vector with the minimum magnitude from a list of vectors.
   * @param vectors - The vectors to compare.
   * @returns The vector with the minimum magnitude.
   */ static minMagnitude(...vectors) {
        return vectors.reduce((prev, curr)=>VectorNUtils.magnitude(curr) < VectorNUtils.magnitude(prev) ? curr : prev);
    }
    /**
   * Calculate the magnitude of a vector.
   * @param a - The vector to calculate the magnitude of.
   * @returns The magnitude of the vector.
   */ static magnitude(a) {
        return Math.sqrt(VectorNUtils.squaredMagnitude(a));
    }
    /**
   * Calculate the squared magnitude of a vector.
   * @param a - The vector to calculate the squared magnitude of.
   * @returns The squared magnitude of the vector.
   */ static squaredMagnitude(a) {
        return a.axes.reduce((sum, val)=>sum + val ** 2, 0);
    }
    /**
   * Calculate the distance between two vectors.
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns The distance between the vectors.
   */ static distance(a, b) {
        return Math.sqrt(VectorNUtils.squaredDistance(a, b));
    }
    /**
   * Calculate the squared distance between two vectors.
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns The squared distance between the vectors.
   */ static squaredDistance(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.axes.reduce((sum, val, index)=>{
            const diff = val - b.get(index);
            return sum + diff ** 2;
        }, 0);
    }
    /**
   * Calculate the dot product of two vectors.
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns The dot product of the vectors.
   */ static dot(a, b) {
        VectorNUtils._assertDimensions(a, b);
        return a.axes.reduce((sum, val, index)=>sum + val * b.get(index), 0);
    }
    /**
   * Normalize a vector.
   * @param a - The vector to normalize.
   * @returns The normalized vector.
   */ static normalize(a) {
        const magnitude = this.magnitude(a);
        if (magnitude) return this.scale(a, 1 / magnitude);
        return this.create(new Array(a.dimensions).fill(0));
    }
    /**
   * Calculate the angle between two vectors.
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns The angle between the vectors in radians.
   */ static angle(a, b) {
        const cosOmega = this.dot(this.normalize(a), this.normalize(b));
        return Math.acos(cosOmega);
    }
    /**
   * Generate a random vector.
   * @param dimensions - The number of dimensions.
   * @param scale - The scale of the random components.
   * @returns The random vector.
   */ static random(dimensions, scale = 1) {
        const axes = Array.from({
            length: dimensions
        }, ()=>Math.random() * 2 - 1);
        return this.scale(this.create(axes), scale);
    }
    /**
   * Perform linear interpolation between two vectors.
   * @param a - The first vector.
   * @param b - The second vector.
   * @param t - The interpolation parameter.
   * @returns The interpolated vector.
   */ static lerp(a, b, t) {
        VectorNUtils._assertDimensions(a, b);
        return a.map((val, index)=>val * (1 - t) + b.get(index) * t);
    }
    /**
   * Perform spherical linear interpolation between two vectors.
   * @param a - The first vector.
   * @param b - The second vector.
   * @param t - The interpolation parameter.
   * @returns The interpolated vector.
   */ static slerp(a, b, t) {
        if (t <= 0) return this.clone(a);
        if (t >= 1) return this.clone(b);
        const omega = this.angle(a, b);
        const sinOmega = Math.sin(omega);
        if (sinOmega <= Number.EPSILON) return this.lerp(a, b, t);
        const ratioA = Math.sin(omega * (1 - t)) / sinOmega;
        const ratioB = Math.sin(omega * t) / sinOmega;
        return a.map((val, index)=>val * ratioA + b.get(index) * ratioB);
    }
    /**
   * Perform Bezier interpolation between vectors.
   * @param points - The control points.
   * @param t - The interpolation parameter.
   * @returns The interpolated vector.
   */ static bezier(points, t) {
        const n = points.length - 1;
        if (!n) return points[0];
        const newPoints = [];
        for(let i = 0; i < n; i++){
            newPoints.push(this.lerp(points[i], points[i + 1], t));
        }
        return this.bezier(newPoints, t);
    }
}

/**
 * Utility class for operations on 3D vectors.
 */ class Vector3Utils extends VectorNUtils {
    /**
   * @param vector - The vector write in array.
   * @returns The vector.
   */ static create(vector) {
        return Vector3.create(vector);
    }
    /**
   * Calculate the cross product of two 3D vectors.
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns The cross product of the vectors.
   */ static cross(a, b) {
        return this.create([
            a.y * b.z - a.z * b.y,
            a.z * b.x - a.x * b.z,
            a.x * b.y - a.y * b.x
        ]);
    }
}

/**
 * Class representing a 3-dimensional vector.
 * @extends VectorN
 */ class Vector3 extends VectorN {
    /**
   * @param vector - The vector write in array.
   * @returns The vector.
   */ static create(vector) {
        if (Array.isArray(vector)) return new this(...vector);
        // @ts-ignore
        if (typeof vector === "string") return this.parse(vector);
        if (typeof vector === "object") return new this(vector.x, vector.y, vector.z);
        throw new Error(`Can't create 3d vector for ${serialize(vector)}`);
    }
    get magnitude() {
        return Vector3Utils.magnitude(this);
    }
    get squaredMagnitude() {
        return Vector3Utils.squaredMagnitude(this);
    }
    get normalized() {
        return Vector3Utils.normalize(this);
    }
    get floored() {
        return Vector3Utils.floor(this);
    }
    get ceiled() {
        return Vector3Utils.ceil(this);
    }
    get rounded() {
        return Vector3Utils.round(this);
    }
    get absoluted() {
        return Vector3Utils.abs(this);
    }
    /**
   * Apply a function to each axes of the vector and return a new vector.
   * @param callbackfn - The function to apply.
   * @returns The new vector.
   */ map(callbackfn) {
        return Vector3.create(this.axes.map(callbackfn));
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    clone() {
        return new Vector3(this.x, this.y, this.z);
    }
    equals(v) {
        return Vector3Utils.equals(this, v);
    }
    distanceTo(v) {
        return Vector3Utils.distance(this, v);
    }
    squaredDistanceTo(v) {
        return Vector3Utils.squaredDistance(this, v);
    }
    add(v) {
        return this.copy(Vector3Utils.add(this, v));
    }
    subtract(v) {
        return this.copy(Vector3Utils.subtract(this, v));
    }
    multiply(v) {
        return this.copy(Vector3Utils.multiply(this, v));
    }
    divide(v) {
        return this.copy(Vector3Utils.divide(this, v));
    }
    scale(n) {
        return this.copy(Vector3Utils.scale(this, n));
    }
    negate() {
        return this.copy(Vector3Utils.negate(this));
    }
    inverse() {
        return this.copy(Vector3Utils.inverse(this));
    }
    floor() {
        return this.copy(this.floored);
    }
    ceil() {
        return this.copy(this.ceiled);
    }
    round() {
        return this.copy(this.rounded);
    }
    abs() {
        return this.copy(this.absoluted);
    }
    normalize() {
        return this.copy(this.normalized);
    }
    /**
   * Create a 3D vector.
   * @param x - The x axis.
   * @param y - The y axis.
   * @param z - The z axis.
   */ constructor(x = 0, y = 0, z = 0){
        super(x, y, z);
    }
}

class Location extends Vector3 {
    get centerCorrected() {
        return Location.create(// @ts-ignore
        Vector3Utils.add(this.floored, new Vector3(0.5, 0.5, 0.5)));
    }
    static create(vector) {
        return Vector3.create(vector);
    }
    clone() {
        return new Location(this.x, this.y, this.z);
    }
    equals(v) {
        return Vector3Utils.exactEquals(this, v);
    }
    isNearTo(v, distance) {
        return this.distanceTo(v) <= distance;
    }
    offset(v) {
        return this.add(v);
    }
}

class LocationInfo {
    textify() {
        return {
            location: `${this.location}`,
            dimension: this.dimension.id
        };
    }
    [Symbol.toPrimitive](hint) {
        if (hint === "string") return `${removeMinecraftNamespace(this.dimension.id)}: ${this.location}`;
        return this;
    }
    constructor({ location, dimension }){
        this.location = location instanceof Location ? location : Location.create(location);
        this.dimension = dimension instanceof Dimension ? dimension : world.getDimension(dimension);
    }
}

const ALL_PLAYER_DATABASES = new Map();
class TpxDB {
    static init(player) {
        const db = new TpxDB(player);
        ALL_PLAYER_DATABASES.set(player, db);
        return db;
    }
    async set({ name, disposable = false, force = false }) {
        const info = new LocationInfo(this.player);
        const handleSet = async ()=>{
            await this.db.set(name, {
                info: info.textify(),
                disposable
            });
            return info;
        };
        if (!force && this.db.has(name)) {
            return await Dialog.confirm({
                body: `名称 ${name} 已被占用，是否覆盖？`,
                target: this.player,
                onConfirm: async ()=>await handleSet()
            });
        }
        return await handleSet();
    }
    async get(name) {
        if (!this.db.has(name)) return;
        const data = this.db.get(name);
        if (!data) return;
        if (data.disposable) await this.db.delete(name);
        if (data.info) return new LocationInfo(data.info);
    }
    async remove(name) {
        if (!this.db.has(name)) return false;
        return await Dialog.confirm({
            body: `是否删除 ${name} `,
            target: this.player,
            onConfirm: async ()=>await this.db.delete(name)
        });
    }
    getAll() {
        const output = [];
        each(this.db, ([name, { info: data, disposable }])=>{
            const info = new LocationInfo(data);
            output.push({
                name,
                info,
                disposable,
                text: `${name} (${info})${disposable ? " [一次性]" : ""}`
            });
        });
        return output;
    }
    constructor(player){
        this.player = player;
        this.db = Database.open(player, "tpx");
    }
}

class EventEmitter {
    on(eventName, listener) {
        if (isAsyncFunc(listener)) {
            const _eventName = `${eventName}.async`;
            if (this._events[_eventName]) this._events[_eventName].push(listener);
            else this._events[_eventName] = [
                listener
            ];
        } else {
            if (this._events[eventName]) this._events[eventName].push(listener);
            else this._events[eventName] = [
                listener
            ];
        }
        return this;
    }
    once(eventName, listener) {
        if (isAsyncFunc(listener)) {
            const _eventName = `${eventName}.async`;
            const _listener = async (...args)=>{
                await listener(...args);
                this.removeListener(_eventName, _listener);
            };
            if (this._events[_eventName]) this._events[_eventName].push(_listener);
            else this._events[_eventName] = [
                _listener
            ];
        } else {
            const _listener = (...args)=>{
                listener(...args);
                this.removeListener(eventName, _listener);
            };
            if (this._events[eventName]) this._events[eventName].push(_listener);
            else this._events[eventName] = [
                _listener
            ];
        }
        return this;
    }
    removeListener(eventName, listener) {
        if (this._events[eventName]) {
            const newListeners = [];
            each(this._events[eventName], (_listener)=>{
                if (_listener !== listener) newListeners.push(_listener);
            });
            this._events[eventName] = newListeners;
        }
        return this;
    }
    async emit(eventName, ...args) {
        if (this._events[eventName]) {
            each(this._events[eventName], (listener)=>listener(...args));
        }
        await this.asyncEmit(eventName, ...args);
    }
    async asyncEmit(eventName, ...args) {
        const _eventName = `${eventName}.async`;
        if (this._events[_eventName]) {
            await eachAsync(this._events[_eventName], async (listener)=>await listener(...args));
        }
    }
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    off(eventName, listener) {
        return this.removeListener(eventName, listener);
    }
    constructor(){
        this._events = {};
    }
}

class NumberRange {
    toArray() {
        return range(this.min, this.max + this.step, this.step);
    }
    get array() {
        return this.toArray();
    }
    includes(n) {
        return this.array.includes(n);
    }
    [Symbol.iterator]() {
        return this.array.values();
    }
    constructor(min, max, step = 1){
        this.min = min;
        this.max = max;
        this.step = step;
    }
}

class OptionItemRange {
    select(value) {
        if (this.selected !== value && this._includes(value)) {
            this.original = this.selected;
            this.selected = value;
            this.events.emit("selected", this.selected, this.original, this._player);
            this.events.emit("changed", this.selected, this.original, this._player);
            return true;
        }
        return false;
    }
    _includes(value) {
        return this.range.includes(value);
    }
    constructor({ name, description, range = [
        0,
        1,
        1
    ], defaultValue, events, reload, _player }){
        this.name = name;
        this.description = description;
        this.range = new NumberRange(...range);
        this.events = new EventEmitter();
        this.reload = reload;
        this._player = _player;
        if (events) each(events, (listener, eventName)=>this.events.on(eventName, listener));
        if (defaultValue !== undefined && this._includes(defaultValue)) this.selected = defaultValue;
        else this.selected = this.range.min;
        this.events.emit("inited", this.selected, _player);
        this.events.emit("changed", this.selected, undefined, _player);
    }
}

class OptionItemSelection {
    select(value) {
        if (this.selected !== value && this.hasVal(value)) {
            this.original = this.selected;
            this.selected = value;
            this.events.emit("selected", this.selected, this.original, this._player);
            this.events.emit("changed", this.selected, this.original, this._player);
            return true;
        }
        return false;
    }
    hasVal(value) {
        return this.values.has(value) || !this.values.size;
    }
    constructor({ name, description, values = [], defaultValue, events, reload, _player }){
        this.name = name;
        this.description = description;
        this.values = new Map(//@ts-ignore
        values.map((value)=>{
            if (value[0] === true && !value[1]) value[1] = "开启";
            else if (value[0] === false && !value[1]) value[1] = "关闭";
            return value;
        }));
        this.events = new EventEmitter();
        this.reload = reload;
        this._player = _player;
        if (events) each(events, (listener, eventName)=>this.events.on(eventName, listener));
        if (defaultValue !== undefined && this.hasVal(defaultValue)) this.selected = defaultValue;
        else if (values[0]) this.selected = values[0][0];
        this.events.emit("inited", this.selected, _player);
        this.events.emit("changed", this.selected, undefined, _player);
    }
}

class PlayerOption {
    addItem(opts) {
        //@ts-ignore
        if (opts.range) this.items[opts.name] = new OptionItemRange(opts);
        else if (opts.values) this.items[opts.name] = new OptionItemSelection(opts);
        return this;
    }
    async _syncToDB() {
        const data = this.getItemValMap();
        await eachAsync(data, async (value, name)=>{
            await this.db.set(name, value);
        });
        await eachAsync(this.db, async ([name, _])=>{
            if (!this.hasItem(name)) await this.db.delete(name);
        });
    }
    async _syncFromDB() {
        each(this.db, ([name, value])=>this.setItemVal(name, value, undefined, {
                syncFromDB: true
            }));
        await this._syncToDB();
    }
    async init() {
        this.addItem = ()=>{
            throw new Error("Can't add item after initialization.");
        };
        await this._syncFromDB();
        return this.getItemValMap();
    }
    _getItem(name) {
        return this.items[name];
    }
    hasItem(name) {
        return !!this.items[name];
    }
    setItemVal(name, value, callback = ()=>{}, { syncFromDB = false } = {}) {
        const item = this._getItem(name);
        if (item) {
            //@ts-ignore
            const result = item.select(value);
            if (result) {
                if (!syncFromDB && item.reload) this.reload = true;
                callback(item.selected, item.original, this.getItemValMap());
            }
        }
        return this;
    }
    getItemVal(name) {
        const item = this._getItem(name);
        if (item) return item.selected;
    }
    getItemValMap() {
        // TODO: use map
        const result = {};
        each(this.items, (_, name)=>{
            result[name] = this.getItemVal(name);
        });
        return result;
    }
    async done(parentDialog) {
        const handleDone = async ({ reply = true } = {})=>{
            await this._syncToDB();
            if (reply) this.player.sendMessage("设置选项修改成功");
        };
        if (this.reload) {
            this.reload = false;
            await Dialog.confirm({
                body: '你选择的项目更改后需要刷新脚本，请手动运行 "/reload" 命令。\n\n您也可以取消您的更改',
                target: this.player,
                onConfirm: async ()=>{
                    await handleDone({
                        reply: false
                    });
                // await Commands.asyncRun("reload")
                },
                onCancel: async ()=>{
                    await this._syncFromDB();
                    await this.showDialog(parentDialog);
                }
            });
        } else await handleDone();
    }
    async showDialog(parentDialog) {
        const form = new ModalFormData().title(`${this.name} 选项`);
        const nameMap = [];
        each(this.items, (item)=>{
            if (item instanceof OptionItemSelection) {
                const { name, description, values, selected } = item;
                if (values.size === 2 && values.get(true) && values.get(false)) {
                    const valuesMap = new Map();
                    each(values, ([e])=>valuesMap.set(e, e));
                    nameMap.push({
                        name,
                        valuesMap
                    });
                    form.toggle(description, selected);
                } else {
                    const valueArray = [
                        ...values
                    ];
                    const valuesMap = new Map();
                    each(valueArray, ([e], i)=>valuesMap.set(i, e));
                    nameMap.push({
                        name,
                        valuesMap
                    });
                    form.dropdown(description, valueArray.map((e)=>e[1]), valueArray.map((e)=>e[0]).findIndex((e)=>e === selected));
                }
            } else if (item instanceof OptionItemRange) {
                const { name, description, range, selected } = item;
                const valuesMap = new Map();
                each(range, (i)=>valuesMap.set(i, i));
                nameMap.push({
                    name,
                    valuesMap
                });
                form.slider(description, range.min, range.max, range.step, selected);
            }
        });
        const dialog = new Dialog({
            dialog: form,
            onClose: async ()=>{
                if (parentDialog) await parentDialog.show(this.player);
            },
            onSubmit: async (result)=>{
                each(result, (valueIndex, nameIndex)=>{
                    const { name, valuesMap } = nameMap[nameIndex];
                    const value = valuesMap.get(valueIndex);
                    this.setItemVal(name, value);
                });
                await this.done(parentDialog);
            }
        });
        await dialog.show(this.player);
    }
    constructor(player, name){
        this.items = {};
        this.reload = false;
        this.name = name;
        this.db = Database.open(player, `option-manager:${name}`);
        this.player = player;
    }
}

class OptionNamespace {
    addItem(opts) {
        this._items.add(opts);
        return this;
    }
    applyPlayer(player) {
        if (this.players.has(player)) return this.players.get(player);
        const playerOpt = new PlayerOption(player, this.name);
        each(this._items, (item)=>{
            item._player = player;
            playerOpt.addItem(item);
        });
        this.players.set(player, playerOpt);
        return playerOpt;
    }
    async applyMainPlayer() {
        const player = await waitForFirstPlayerInitialSpawn();
        return this.applyPlayer(player);
    }
    async init() {
        const valueMap = new Map();
        await eachAsync(this.players, async ([player, playerOpt])=>{
            const result = await playerOpt.init();
            valueMap.set(player, result);
        });
        this.applyPlayer = ()=>{
            throw new Error("Can't apply player after initialization.");
        };
        return valueMap;
    }
    getPlayer(player) {
        const playerOption = this.players.get(player);
        if (!playerOption) throw new Error("Can't get player  options.");
        return playerOption;
    }
    constructor(name){
        this.players = new Map();
        this._items = new Set();
        this.name = name;
    }
}

class OptionManager {
    registerNamesapace(name) {
        const namespaces = new OptionNamespace(name);
        this.namespaces.set(name, namespaces);
        return namespaces;
    }
    getNamesapace(name) {
        const namespace = this.namespaces.get(name);
        if (!namespace) throw new Error("Can't get namespace.");
        return namespace;
    }
    async showDialog(player) {
        const form = new ActionFormData().title("设置选项").body("选择要设置的模块：");
        const nameMap = [];
        each(this.namespaces, ([name])=>{
            nameMap.push(name);
            form.button(name) // TODO: name -> desc
            ;
        });
        const dialog = new Dialog({
            dialog: form,
            onSelect: async (selection)=>{
                const name = nameMap[selection];
                await this.getNamesapace(name).getPlayer(player).showDialog(dialog);
            }
        });
        await dialog.show(player);
    }
    constructor(){
        this.namespaces = new Map();
    }
}

const optionManager = new OptionManager();

Commands.register("!", "option", async (argv, sender)=>{
    switch(argv[1]){
        case "dialog":
        case "-d":
        case undefined:
            {
                // TODO argv[2] -> namespace
                await asyncRun(()=>optionManager.showDialog(sender));
                break;
            }
        default:
            {
                throw errorHandler("未知的子命令", sender);
            }
    }
});

async function afterEntityDieCallback(event) {
    const player = event.deadEntity;
    const handler = new Handler(player);
    await handler.set({
        name: "__death__",
        option: {
            disposable: true,
            force: true
        }
    });
}
const option = optionManager.registerNamesapace("tpx").addItem({
    name: "auto_back_point",
    description: "允许使用 tpx 传送时自动添加返回点",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: true,
    events: {
        changed: (selected, original)=>console.warn("tpx:auto_back_point -> from", original, "to", selected)
    }
}).addItem({
    name: "back_after_death",
    description: "允许死亡时自动添加死亡点",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: true,
    events: {
        changed: (selected, original)=>{
            console.warn("tpx:back_after_death -> from", original, "to", selected);
            if (selected) world.afterEvents.entityDie.subscribe(afterEntityDieCallback, {
                entityTypes: [
                    "minecraft:player"
                ]
            });
            else world.afterEvents.entityDie.unsubscribe(afterEntityDieCallback);
        }
    }
}).addItem({
    name: "back_cmd",
    description: "允许使用独立的 back 命令",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: false,
    reload: true,
    events: {
        changed: (selected, original)=>console.warn("tpx:back_cmd -> from", original, "to", selected)
    }
}).addItem({
    name: "home_cmd",
    description: "允许使用独立的 home 命令",
    values: [
        [
            true
        ],
        [
            false
        ]
    ],
    defaultValue: false,
    reload: true,
    events: {
        changed: (selected, original)=>console.warn("tpx:home_cmd -> from", original, "to", selected)
    }
});

class Handler {
    async set({ name = "default", option = {} }) {
        const info = await this.playerDB.set(Object.assign({
            name
        }, option));
        if (name !== "__back__" && name !== "__death__") return {
            info
        };
    }
    async remove({ name = "default" }) {
        return await this.playerDB.remove(name);
    }
    async teleport({ name = "default" }) {
        const info = await this.playerDB.get(name);
        if (info) {
            if (this.playerOption.getItemVal("auto_back_point") && name !== "__death__") {
                await this.set({
                    name: "__back__",
                    option: {
                        disposable: true,
                        force: true
                    }
                });
            }
            await asyncRun(()=>this.player.teleport(info.location, {
                    dimension: info.dimension,
                    checkForBlocks: false,
                    keepVelocity: false
                }));
            return {
                info
            };
        }
    }
    async tryTeleport({ names = [] }) {
        for (const name of names){
            const result = await this.teleport({
                name
            });
            if (result) return result;
        }
    }
    list() {
        const datas = this.playerDB.getAll().map(({ text })=>text);
        if (datas.length) return {
            msg: datas
        };
    }
    constructor(player){
        this.player = player;
        this.playerOption = option.getPlayer(player);
        const playerDB = ALL_PLAYER_DATABASES.get(player);
        if (!playerDB) throw new Error("Can't get player database.");
        this.playerDB = playerDB;
    }
}

const SUB_COMMANDS = [
    "set",
    "-s",
    "remove",
    "rm",
    "-r",
    "back",
    "bk",
    "-b",
    "list",
    "ls",
    "-l",
    "help",
    "-h",
    "option",
    "opt",
    "-o"
];
async function tpxCommand(argv, sender) {
    const name = argv[2] ?? "default";
    const handler = new Handler(sender);
    switch(argv[1]){
        case "set":
        case "-s":
            {
                if (SUB_COMMANDS.includes(name) || name === "__back__") throw errorHandler(`添加失败：不能使用 ${name} 作为名称`, sender);
                const result = await handler.set({
                    name,
                    option: {
                        disposable: argv[3] === "true" ? true : argv[3] === "false" ? false : undefined
                    }
                });
                if (result) sender.sendMessage(`成功设置 ${name} 在 ${result.info}`);
                break;
            }
        case "remove":
        case "rm":
        case "-r":
            {
                const result = await handler.remove({
                    name
                });
                if (result === true) sender.sendMessage(`成功删除 ${name}`);
                else if (result === false) throw errorHandler(`删除失败：未找到 ${name}`, sender);
                break;
            }
        case "back":
        case "bk":
        case "-b":
            {
                const result = await handler.tryTeleport({
                    names: [
                        "__death__",
                        "__back__"
                    ]
                });
                if (result) sender.sendMessage(`已返回到 ${result.info}`);
                else throw errorHandler("传送失败：未找到返回点", sender);
                break;
            }
        case "list":
        case "ls":
        case "-l":
            {
                const result = handler.list();
                if (result) {
                    result.msg.unshift("您的传送点有：");
                    sender.sendMessage(result.msg.join("\n- "));
                } else sender.sendMessage("您目前没有传送点");
                break;
            }
        case "help":
        case "-h":
            {
                // TODO command-parser
                sender.sendMessage("制作中...");
                break;
            }
        case "option":
        case "opt":
        case "-o":
            {
                await asyncRun(()=>option.getPlayer(sender).showDialog());
                break;
            }
        default:
            {
                const result = await handler.teleport({
                    name: argv[1]
                });
                if (result) sender.sendMessage(`已传送到 ${result.info}`);
                else throw errorHandler(`传送失败：未找到传送点 ${argv[1]}`, sender);
            }
    }
}
async function backCommand(_, sender) {
    if (option.getPlayer(sender).getItemVal("back_cmd")) await Commands.asyncRun("!tpx back", sender);
    else sender.sendMessage("您未启用该命令");
}
async function homeCommand(argv, sender) {
    if (option.getPlayer(sender).getItemVal("home_cmd")) {
        switch(argv[1]){
            case "set":
                {
                    await Commands.asyncRun("!tpx set __home__", sender);
                    break;
                }
            default:
                {
                    await Commands.asyncRun("!tpx __home__", sender);
                }
        }
    } else sender.sendMessage("您未启用该命令");
}

option.applyMainPlayer().then(()=>each(world.getAllPlayers(), (player)=>option.applyPlayer(player))).then(()=>option.init()).then((optMap)=>{
    // 将所有玩家的数据库实例化并储存在 ALL_PLAYER_DATABASES 中
    // 同时避免在 beforeEvent 中构建导致的 read-only mode 问题
    const players = optMap.keys();
    each(players, (player)=>TpxDB.init(player));
    Commands.register("!", "tpx", tpxCommand);
    const values = [
        ...optMap.values()
    ];
    if (values.some(({ back_cmd })=>back_cmd)) Commands.register("!", "back", backCommand);
    if (values.some(({ home_cmd })=>home_cmd)) Commands.register("!", "home", homeCommand);
}).catch(BetterConsole.error);
//# sourceMappingURL=tpx.js.map
